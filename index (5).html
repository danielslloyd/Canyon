<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canyon Flight</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        #hud div {
            margin-bottom: 8px;
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            max-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #controls-panel h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 8px;
        }

        #controls-panel label {
            display: block;
            margin: 8px 0 4px;
        }

        #controls-panel input[type="range"] {
            width: 100%;
        }

        #controls-panel select, #controls-panel button {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            border-radius: 4px;
            border: none;
        }

        #controls-panel button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            margin-top: 10px;
        }

        #controls-panel button:hover {
            background: #45a049;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .checkbox-container input {
            margin-right: 8px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 12px;
            color: white;
            text-align: center;
            display: none;
        }

        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff4444;
        }

        #game-over p {
            font-size: 20px;
            margin-bottom: 20px;
        }

        #game-over button {
            padding: 12px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            text-align: center;
        }

        .value-display {
            color: #88ff88;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Rings: <span id="rings-collected">0</span></div>
            <div>Health: <span id="health">100</span></div>
        </div>

        <div id="controls-panel">
            <h3>Settings</h3>

            <label>Time of Day:</label>
            <select id="time-of-day">
                <option value="morning" selected>Morning (Fog)</option>
                <option value="noon">Noon</option>
                <option value="sunset">Sunset</option>
            </select>

            <label>Canyon Detail (LOD): <span id="lod-value" class="value-display">12</span></label>
            <input type="range" id="canyon-lod" min="2" max="20" value="12">

            <label>Ring Frequency: <span id="ring-freq-value" class="value-display">0</span></label>
            <input type="range" id="ring-frequency" min="0" max="10" value="0">

            <label>Ring Rotation Axis:</label>
            <select id="ring-rotation-axis">
                <option value="x">X-axis</option>
                <option value="y">Y-axis</option>
                <option value="z" selected>Z-axis (default)</option>
                <option value="xy">X+Y axes</option>
                <option value="xz">X+Z axes</option>
                <option value="yz">Y+Z axes</option>
            </select>

            <label>Flight Speed: <span id="speed-value" class="value-display">5</span>x</label>
            <input type="range" id="flight-speed" min="0.5" max="10" step="0.1" value="5">

            <label>Autopilot Mode:</label>
            <select id="autopilot-mode">
                <option value="off">Off</option>
                <option value="alpha">Alpha (Path Following)</option>
                <option value="beta" selected>Beta (Longest Path)</option>
            </select>

            <div class="checkbox-container">
                <input type="checkbox" id="enemies-enabled">
                <label for="enemies-enabled">Enable Enemy Planes</label>
            </div>

            <label>Enemy Difficulty: <span id="enemy-diff-value" class="value-display">5</span></label>
            <input type="range" id="enemy-difficulty" min="1" max="10" value="5">

            <div class="checkbox-container">
                <input type="checkbox" id="visual-debugging">
                <label for="visual-debugging">Visual Debugging</label>
            </div>

            <label>Replay Backtrack Distance: <span id="replay-backtrack-value" class="value-display">100</span> units</label>
            <input type="range" id="replay-backtrack" min="20" max="300" step="10" value="100">

            <div class="checkbox-container">
                <input type="checkbox" id="reroll-canyon" checked>
                <label for="reroll-canyon">Re-roll Canyon on Restart</label>
            </div>

            <button id="apply-settings">Apply Settings</button>
        </div>

        <div id="game-over">
            <h2>CRASHED!</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="replay-btn">Replay (Debug)</button>
            <button id="restart-btn">Restart</button>
        </div>

        <div id="instructions">
            <strong>Controls:</strong> W/S - Pitch | A/D - Roll | Space - Shoot | P - Pause
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Game Configuration
        const CONFIG = {
            canyonWidth: 120,
            canyonHeight: 200,
            canyonDepth: 2000,
            segmentLength: 100,
            visibleSegments: 25,
            lodLevel: 12,
            ringFrequency: 0,
            ringRotationAxis: 'z',  // Z-axis is correct
            flightSpeed: 5,
            enemiesEnabled: false,
            enemyDifficulty: 5,
            timeOfDay: 'morning',
            autopilotMode: 'beta',  // 'off', 'alpha', or 'beta'
            visualDebugging: false,
            replayBacktrackDistance: 100,  // Distance to backtrack for replay
            rerollCanyonOnRestart: true
        };

        // Game State
        let score = 0;
        let ringsCollected = 0;
        let health = 100;
        let gameOver = false;
        let paused = false;

        // Replay system - rolling buffer of recent states
        const stateHistory = [];
        const maxHistorySize = 1000;  // Keep last 1000 states
        let crashState = null;  // Store state at crash

        // Three.js components
        // This work is based on "F22 (Remaster)" (https://sketchfab.com/3d-models/f22-remaster-bf6df655e73e4d4b9deac6cfee85564c) by CreaDX (https://sketchfab.com/CreaDX) licensed under CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
        let scene, camera, renderer;
        let aircraft, aircraftGroup;
        let canyonSegments = [];
        let rings = [];
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let autopilotPathLine = null;
        let canyonCenterLine = null;
        let bestPathLine = null;
        let transitionPathLine = null;
        let debugPitchCircle = null;
        let debugRollCircle = null;
        let debugCollisionBox = null;
        let betaDebugRedLines = [];   // Red sample lines (cleared each frame)
        let betaDebugGreenLines = [];  // Green chosen lines (persistent)
        let betaDebugSphereBatches = [];  // Array of sphere batches (keep last 2 samples)

        // Plane dimensions - will be calculated from F22 model
        let PLANE_DIMS = {
            wingspan: 8,      // Half-wingspan (from center to tip)
            length: 12,       // Nose to tail
            height: 4,        // Bottom to top
            fuselageRadius: 3 // Collision radius for fuselage
        };

        // Controls
        const keys = {};
        let pitch = 0;
        let roll = 0;
        let yaw = 0;
        let lastCanyonOffset = 0;

        // Beta autopilot tracking
        let betaLastSamplePos = null;  // Track position of last sample
        let betaBestDistance = 0;  // Track best path distance from last sample
        let betaStraightAheadDistance = 0;  // Track straight-ahead path distance from last sample
        let betaBestDirection = null;  // Track best direction between samples
        let betaBestAngle = 0;  // Track best steering angle (in radians)

        // Position tracking
        let playerZ = 0;
        let lastSegmentZ = 0;

        // Canyon path - stores the center X position at each Z
        const canyonPath = new Map();

        // Noise function for fractal terrain
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;

                // Shuffle
                let n, q;
                for (let i = 255; i > 0; i--) {
                    n = Math.floor((seed = (seed * 16807) % 2147483647) / 2147483647 * (i + 1));
                    q = this.p[i];
                    this.p[i] = this.p[n];
                    this.p[n] = q;
                }

                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1))
                );
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            // Fractal Brownian Motion for more detailed terrain
            fbm(x, y, octaves = 6, persistence = 0.5, lacunarity = 2.0) {
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    value += amplitude * this.noise2D(x * frequency, y * frequency);
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }

                return value / maxValue;
            }
        }

        let noise = new SimplexNoise(12345);
        let pathNoise = new SimplexNoise(67890);

        // Get canyon center position at a given Z
        function getCanyonCenter(z) {
            // Create pronounced S-curves with varying radius and angle
            // Primary large S-curves (increased amplitude for sharper curves)
            const curve1 = pathNoise.noise2D(z * 0.0015, 0) * 120;  // Increased from 80
            // Secondary curves for variation in turn radius
            const curve2 = pathNoise.noise2D(z * 0.004, 100) * 60;  // Increased from 40
            // Tertiary detail curves
            const curve3 = pathNoise.noise2D(z * 0.01, 200) * 25;  // Increased from 15
            // Extra variation in turn sharpness
            const curve4 = Math.sin(z * 0.002 + pathNoise.noise2D(z * 0.001, 300) * 2) * 70;  // Increased from 50

            return curve1 + curve2 + curve3 + curve4;
        }

        // Get cross-section shape factor (0 = V-shape, 1 = U-shape)
        function getCrossSectionShape(z) {
            return (pathNoise.noise2D(z * 0.005, 500) + 1) / 2;
        }

        // Get canyon width multiplier (varies between 1x and 2x)
        function getCanyonWidthMultiplier(z) {
            return 1.0 + (pathNoise.noise2D(z * 0.003, 700) + 1) / 2;
        }

        // Get canyon rim height variation (dramatic variation)
        function getCanyonRimHeight(z) {
            // Base height + dramatic variation
            const base = CONFIG.canyonHeight;
            const variation = pathNoise.noise2D(z * 0.004, 900) * 200; // +/- 200 units (2x max height)
            return base + variation;
        }

        // Calculate actual wall X positions at a given (z, y) coordinate
        // This matches the wall generation logic in createCanyonSegment
        function getActualWallPositions(z, y) {
            const localCenterX = getCanyonCenter(z);
            const localCrossSection = getCrossSectionShape(z);
            const localWidthMult = getCanyonWidthMultiplier(z);
            const localHalfWidth = (CONFIG.canyonWidth / 2) * localWidthMult;
            const localRimHeight = getCanyonRimHeight(z);

            // Calculate yFrac (normalized height)
            const yFrac = y / localRimHeight;

            // Wall angle: V-shape has angled walls, U-shape has more vertical walls
            const baseAngle = 0.15 + localCrossSection * 0.6; // 0.15 to 0.75
            const wallAngle = baseAngle + noise.fbm(z * 0.01, y * 0.02, 3) * 0.1;

            // Top extension - walls extend outward near the top
            let topExtension = 0;
            if (yFrac > 0.7) {
                const extendFrac = (yFrac - 0.7) / 0.3;
                topExtension = extendFrac * extendFrac * 60;
            }

            // Left wall base position (wall leans inward at bottom)
            const leftBaseX = localCenterX - localHalfWidth + (1 - yFrac) * localHalfWidth * (1 - wallAngle) - topExtension;

            // Fractal displacement (matches LOD scaling from canyon generation)
            const octaves = Math.max(3, Math.min(CONFIG.lodLevel, 16));  // Higher octave range for more detail
            const leftDisplacement = noise.fbm(z * 0.01, y * 0.05, octaves, 0.5, 2.0) * 12;  // Constant displacement magnitude
            const leftX = leftBaseX - leftDisplacement;

            // Right wall base position
            const rightBaseX = localCenterX + localHalfWidth - (1 - yFrac) * localHalfWidth * (1 - wallAngle) + topExtension;
            const rightDisplacement = noise.fbm(z * 0.01 + 100, y * 0.05, octaves, 0.5, 2.0) * 12;  // Same constant displacement
            const rightX = rightBaseX + rightDisplacement;

            return { leftWall: leftX, rightWall: rightX, canyonCenterX: localCenterX };
        }

        // Calculate optimal flight path - simply follow canyon center (green line)
        // Returns {x, y} position at given z
        function getOptimalFlightPath(z, currentX = 0) {
            // Simply follow the canyon center
            const centerX = getCanyonCenter(z);

            // Target height: middle of flight envelope for maximum clearance
            const floorHeight = 8; // Safe floor height from collision detection
            const ceilingHeight = CONFIG.canyonHeight - 110; // Safe ceiling
            const targetY = (floorHeight + ceilingHeight) / 2; // Middle altitude

            return { x: centerX, y: targetY };
        }

        // Initialize the game
        async function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 10, 30);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Create game elements
            createSkybox();
            setupLighting();
            await createAircraft();  // Wait for aircraft to load
            createInitialCanyon();

            // Event listeners
            setupEventListeners();

            // Start game loop
            animate();
        }

        function createSkybox() {
            updateSkybox();
        }

        function updateSkybox(centerOnPlayer = false) {
            // Remove old skybox
            const oldSkybox = scene.getObjectByName('skybox');
            if (oldSkybox) scene.remove(oldSkybox);

            let skyColors;
            switch (CONFIG.timeOfDay) {
                case 'morning':
                    skyColors = {
                        top: new THREE.Color(0x87CEEB),
                        bottom: new THREE.Color(0xFFE4B5)
                    };
                    break;
                case 'noon':
                    skyColors = {
                        top: new THREE.Color(0x0077FF),
                        bottom: new THREE.Color(0x87CEEB)
                    };
                    break;
                case 'sunset':
                    skyColors = {
                        top: new THREE.Color(0x1a0533),
                        bottom: new THREE.Color(0xFF6B35)
                    };
                    break;
            }

            // Set up fog for morning
            if (CONFIG.timeOfDay === 'morning') {
                // Exponential fog that follows camera automatically
                // Use a color that blends better with the sky and water (light blue-gray)
                scene.fog = new THREE.FogExp2(0xB8D8E8, 0.0012);  // Lighter, more blue-tinted fog, reduced density
            } else {
                scene.fog = null;
            }

            // Gradient sky sphere
            const skyGeo = new THREE.SphereGeometry(2000, 32, 32);
            const skyMatConfig = {
                uniforms: THREE.UniformsUtils.merge([
                    THREE.UniformsLib.fog,
                    {
                        topColor: { value: skyColors.top },
                        bottomColor: { value: skyColors.bottom },
                        offset: { value: 400 },
                        exponent: { value: 0.6 }
                    }
                ]),
                vertexShader: `
                    varying vec3 vWorldPosition;
                    #ifdef USE_FOG
                        varying float vFogDepth;
                    #endif
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        #ifdef USE_FOG
                            vFogDepth = -mvPosition.z;
                        #endif
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;

                    #ifdef USE_FOG
                        uniform vec3 fogColor;
                        varying float vFogDepth;
                        #ifdef FOG_EXP2
                            uniform float fogDensity;
                        #else
                            uniform float fogNear;
                            uniform float fogFar;
                        #endif
                    #endif

                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        vec3 skyColor = mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));

                        #ifdef USE_FOG
                            float fogFactor = 1.0;
                            #ifdef FOG_EXP2
                                fogFactor = 1.0 - exp(-fogDensity * fogDensity * vFogDepth * vFogDepth);
                            #else
                                fogFactor = smoothstep(fogNear, fogFar, vFogDepth);
                            #endif
                            skyColor = mix(skyColor, fogColor, fogFactor);
                        #endif

                        gl_FragColor = vec4(skyColor, 1.0);
                    }
                `,
                side: THREE.BackSide,
                fog: true
            };

            // Add fog defines if fog is enabled
            if (CONFIG.timeOfDay === 'morning') {
                skyMatConfig.defines = {
                    USE_FOG: '',
                    FOG_EXP2: ''
                };
            }

            const skyMat = new THREE.ShaderMaterial(skyMatConfig);
            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = 'skybox';

            // Center on player if requested
            if (centerOnPlayer && aircraft) {
                sky.position.copy(aircraft.position);
            }

            scene.add(sky);
        }


        let sunLight, sunVisual;

        function setupLighting() {
            // Remove old lights and sun visual
            scene.children = scene.children.filter(child =>
                !(child instanceof THREE.Light) && child.name !== 'sunVisual'
            );
            sunLight = null;
            sunVisual = null;

            // Ambient light
            let ambientIntensity, ambientColor;
            let sunPosition, sunColor, sunIntensity;

            switch (CONFIG.timeOfDay) {
                case 'morning':
                    ambientIntensity = 0.4;
                    ambientColor = 0xB0C4DE;
                    sunPosition = new THREE.Vector3(100, 30, -100);
                    sunColor = 0xFFE4C4;
                    sunIntensity = 1.0;
                    break;
                case 'noon':
                    // Harsh directional light for noon
                    ambientIntensity = 0.2;
                    ambientColor = 0xFFFFFF;
                    sunPosition = new THREE.Vector3(0, 200, -50);
                    sunColor = 0xFFFFFF;
                    sunIntensity = 2.5;
                    break;
                case 'sunset':
                    ambientIntensity = 0.3;
                    ambientColor = 0xFF8C69;
                    sunPosition = new THREE.Vector3(-200, 20, -100);
                    sunColor = 0xFF4500;
                    sunIntensity = 1.2;
                    break;
            }

            const ambient = new THREE.AmbientLight(ambientColor, ambientIntensity);
            scene.add(ambient);

            // Directional light (sun)
            sunLight = new THREE.DirectionalLight(sunColor, sunIntensity);
            sunLight.position.copy(sunPosition);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -150;
            sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150;
            sunLight.shadow.camera.bottom = -150;
            sunLight.userData.initialPosition = sunPosition.clone();
            scene.add(sunLight);

            // Add sun visual for sunset
            if (CONFIG.timeOfDay === 'sunset') {
                const sunGeo = new THREE.SphereGeometry(30, 32, 32);
                const sunMat = new THREE.MeshBasicMaterial({
                    color: 0xFF6600,
                    transparent: true,
                    opacity: 0.9
                });
                sunVisual = new THREE.Mesh(sunGeo, sunMat);
                sunVisual.position.copy(sunPosition).multiplyScalar(5);
                sunVisual.name = 'sunVisual';
                sunVisual.userData.initialPosition = sunVisual.position.clone();
                scene.add(sunVisual);
            }
        }

        function updateLightingPosition() {
            if (sunLight && aircraft) {
                const offset = sunLight.userData.initialPosition;
                sunLight.position.copy(aircraft.position).add(offset);
                sunLight.target.position.copy(aircraft.position);
                sunLight.target.updateMatrixWorld();
            }
            if (sunVisual && aircraft) {
                const offset = sunVisual.userData.initialPosition;
                sunVisual.position.copy(aircraft.position).add(offset);
            }
        }

        function updateDebugCircles() {
            if (!aircraft) return;

            // Remove old circles
            if (debugPitchCircle) {
                scene.remove(debugPitchCircle);
            }
            if (debugRollCircle) {
                scene.remove(debugRollCircle);
            }

            // Don't create new circles if debugging is disabled
            if (!CONFIG.visualDebugging) return;

            // Calculate bounding sphere radius for the plane
            const planeRadius = 8;  // Approximate radius for visualization

            // Create pitch axis circle (RED) - rotation around X-axis (lateral)
            // This circle is in the YZ plane of the plane's local coordinate system
            const pitchPoints = [];
            const segments = 64;
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                // Circle in local YZ plane (perpendicular to X-axis)
                const localPoint = new THREE.Vector3(
                    0,  // No X component - perpendicular to X-axis
                    Math.cos(theta) * planeRadius,
                    Math.sin(theta) * planeRadius
                );
                // Transform to world space using plane's rotation
                localPoint.applyQuaternion(aircraft.quaternion);
                localPoint.add(aircraft.position);
                pitchPoints.push(localPoint);
            }

            const pitchGeometry = new THREE.BufferGeometry().setFromPoints(pitchPoints);
            const pitchMaterial = new THREE.LineBasicMaterial({
                color: 0xFF0000,  // Red
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            debugPitchCircle = new THREE.Line(pitchGeometry, pitchMaterial);
            scene.add(debugPitchCircle);

            // Create roll axis circle (BLUE) - rotation around Z-axis (longitudinal)
            // This circle is in the XY plane of the plane's local coordinate system
            const rollPoints = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                // Circle in local XY plane (perpendicular to Z-axis)
                const localPoint = new THREE.Vector3(
                    Math.cos(theta) * planeRadius,
                    Math.sin(theta) * planeRadius,
                    0  // No Z component - perpendicular to Z-axis (forward)
                );
                // Transform to world space using plane's rotation
                localPoint.applyQuaternion(aircraft.quaternion);
                localPoint.add(aircraft.position);
                rollPoints.push(localPoint);
            }

            const rollGeometry = new THREE.BufferGeometry().setFromPoints(rollPoints);
            const rollMaterial = new THREE.LineBasicMaterial({
                color: 0x0000FF,  // Blue
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            debugRollCircle = new THREE.Line(rollGeometry, rollMaterial);
            scene.add(debugRollCircle);
        }

        function updateCollisionBoxDebug() {
            if (!aircraft) return;

            // Remove old debug meshes
            if (debugCollisionBox) {
                scene.remove(debugCollisionBox);
            }

            // Don't create new collision box if debugging is disabled
            if (!CONFIG.visualDebugging) return;

            debugCollisionBox = new THREE.Group();

            // Create tight bounding box using PLANE_DIMS
            const boxGeometry = new THREE.BoxGeometry(
                PLANE_DIMS.wingspan * 2,  // Full wingspan
                PLANE_DIMS.height,         // Height
                PLANE_DIMS.length          // Length
            );
            const boxMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,  // Yellow
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            const box = new THREE.Mesh(boxGeometry, boxMaterial);

            // Position and orient with the plane
            box.position.copy(aircraft.position);
            box.quaternion.copy(aircraft.quaternion);
            debugCollisionBox.add(box);

            scene.add(debugCollisionBox);
        }

        function updateDebugLines() {
            if (!aircraft) return;

            // Remove old lines
            if (autopilotPathLine) {
                scene.remove(autopilotPathLine);
            }
            if (canyonCenterLine) {
                scene.remove(canyonCenterLine);
            }
            if (bestPathLine) {
                scene.remove(bestPathLine);
            }
            if (transitionPathLine) {
                scene.remove(transitionPathLine);
            }

            // Don't create new lines if debugging is disabled
            if (!CONFIG.visualDebugging) return;

            const startZ = aircraft.position.z + 50;  // Start a bit behind
            const endZ = aircraft.position.z - 800;   // Extend far ahead
            const step = 10;

            // Purple line: Canyon center at fixed height (old autopilot reference)
            const targetHeight = 30;
            const autopilotPoints = [];
            for (let z = startZ; z >= endZ; z -= step) {
                const centerX = getCanyonCenter(z);
                autopilotPoints.push(new THREE.Vector3(centerX, targetHeight, z));
            }

            const autopilotGeometry = new THREE.BufferGeometry().setFromPoints(autopilotPoints);
            const autopilotMaterial = new THREE.LineDashedMaterial({
                color: 0xFF00FF,      // Purple/magenta
                linewidth: 5,
                scale: 1,
                dashSize: 5,
                gapSize: 3
            });

            autopilotPathLine = new THREE.Line(autopilotGeometry, autopilotMaterial);
            autopilotPathLine.computeLineDistances();
            scene.add(autopilotPathLine);

            // Green line: Canyon center at plane's current height
            const canyonCenterPoints = [];
            for (let z = startZ; z >= endZ; z -= step) {
                const centerX = getCanyonCenter(z);
                canyonCenterPoints.push(new THREE.Vector3(centerX, aircraft.position.y, z));
            }

            const canyonCenterGeometry = new THREE.BufferGeometry().setFromPoints(canyonCenterPoints);
            const canyonCenterMaterial = new THREE.LineDashedMaterial({
                color: 0x00FF00,      // Green
                linewidth: 5,
                scale: 1,
                dashSize: 5,
                gapSize: 3
            });

            canyonCenterLine = new THREE.Line(canyonCenterGeometry, canyonCenterMaterial);
            canyonCenterLine.computeLineDistances();
            scene.add(canyonCenterLine);

            // Cyan line: Best path (optimal flight path ahead)
            const bestPathPoints = [];
            let currentX = aircraft.position.x;
            for (let z = startZ; z >= endZ; z -= step) {
                const optimalPos = getOptimalFlightPath(z, currentX);
                bestPathPoints.push(new THREE.Vector3(optimalPos.x, optimalPos.y, z));
                currentX = optimalPos.x;
            }

            const bestPathGeometry = new THREE.BufferGeometry().setFromPoints(bestPathPoints);
            const bestPathMaterial = new THREE.LineBasicMaterial({
                color: 0x00FFFF,      // Cyan
                linewidth: 6,
                transparent: true,
                opacity: 0.8
            });

            bestPathLine = new THREE.Line(bestPathGeometry, bestPathMaterial);
            scene.add(bestPathLine);

            // Orange line: Transition path (how plane will get to best line)
            // Calculate smooth transition from current position to optimal path
            const transitionPoints = [];
            const transitionSteps = 30;  // Number of steps in transition
            const lookAhead = 150;  // Match autopilot lookahead

            for (let i = 0; i <= transitionSteps; i++) {
                const t = i / transitionSteps;  // 0 to 1
                const z = aircraft.position.z - (t * lookAhead);

                // Get optimal position at this Z
                const optimalPos = getOptimalFlightPath(z, aircraft.position.x);

                // Smooth interpolation from current position to optimal path
                const smoothing = Math.pow(t, 1.5);  // Ease-in curve
                const x = THREE.MathUtils.lerp(aircraft.position.x, optimalPos.x, smoothing);
                const y = THREE.MathUtils.lerp(aircraft.position.y, optimalPos.y, smoothing);

                transitionPoints.push(new THREE.Vector3(x, y, z));
            }

            const transitionGeometry = new THREE.BufferGeometry().setFromPoints(transitionPoints);
            const transitionMaterial = new THREE.LineBasicMaterial({
                color: 0xFFA500,      // Orange
                linewidth: 4,
                transparent: true,
                opacity: 0.9
            });

            transitionPathLine = new THREE.Line(transitionGeometry, transitionMaterial);
            scene.add(transitionPathLine);
        }

        function createSimpleDeltaWing() {
            // Simple, clean delta wing fighter
            const group = new THREE.Group();

            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0x6B7280,
                flatShading: true
            });

            // Fuselage (simple elongated diamond shape)
            const fuselageGeo = new THREE.ConeGeometry(0.5, 4, 4);
            const fuselage = new THREE.Mesh(fuselageGeo, bodyMat);
            fuselage.rotation.x = -Math.PI / 2;
            fuselage.castShadow = true;
            group.add(fuselage);

            // Delta wing (single swept wing)
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);      // Center front
            wingShape.lineTo(-4, 2);     // Left tip
            wingShape.lineTo(0, 1.5);    // Back center
            wingShape.lineTo(4, 2);      // Right tip
            wingShape.lineTo(0, 0);      // Back to front

            const wingGeo = new THREE.ShapeGeometry(wingShape);
            const wing = new THREE.Mesh(wingGeo, bodyMat);
            wing.rotation.x = -Math.PI / 2;
            wing.position.y = -0.1;
            wing.castShadow = true;
            group.add(wing);

            // Single vertical stabilizer
            const tailGeo = new THREE.ConeGeometry(0.3, 1.2, 3);
            const tail = new THREE.Mesh(tailGeo, bodyMat);
            tail.position.y = 0.6;
            tail.position.z = 1.5;
            tail.castShadow = true;
            group.add(tail);

            // Cockpit
            const canopyGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const canopyMat = new THREE.MeshPhongMaterial({
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.7
            });
            const canopy = new THREE.Mesh(canopyGeo, canopyMat);
            canopy.position.z = -0.8;
            canopy.position.y = 0.2;
            canopy.scale.set(1, 0.8, 1.3);
            group.add(canopy);

            group.scale.set(1.5, 1.5, 1.5);
            return group;
        }

        async function createAircraft() {
            aircraftGroup = new THREE.Group();

            // Try to load F22 model from assets folder
            const loader = new GLTFLoader();
            const modelPaths = [
                './assets/f22.gltf',
                './assets/F22.gltf',
                './assets/f22.glb',
                './assets/F22.glb'
            ];

            let modelLoaded = false;

            for (const path of modelPaths) {
                try {
                    console.log('Attempting to load model from:', path);
                    const gltf = await loader.loadAsync(path);
                    const model = gltf.scene;

                    // Check if model has any meshes
                    let hasMeshes = false;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            hasMeshes = true;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    if (!hasMeshes) {
                        console.warn('Model loaded but contains no meshes:', path);
                        continue;
                    }

                    // Scale and orient the model
                    model.scale.set(4, 4, 4);  // 2x larger than before
                    // Rotate model: if left wing points forward and nose points right,
                    // we need -90Â° rotation to make nose point forward
                    model.rotation.y = -Math.PI / 2;

                    aircraftGroup.add(model);

                    // Calculate tight bounding box from actual model vertices
                    aircraftGroup.updateMatrixWorld(true);

                    // Calculate bounding box from all mesh vertices
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    let minZ = Infinity, maxZ = -Infinity;

                    model.traverse((child) => {
                        if (child.isMesh && child.geometry) {
                            const geometry = child.geometry;
                            const positionAttribute = geometry.getAttribute('position');

                            if (positionAttribute) {
                                const vertex = new THREE.Vector3();
                                for (let i = 0; i < positionAttribute.count; i++) {
                                    vertex.fromBufferAttribute(positionAttribute, i);
                                    // Transform vertex to world space
                                    vertex.applyMatrix4(child.matrixWorld);

                                    minX = Math.min(minX, vertex.x);
                                    maxX = Math.max(maxX, vertex.x);
                                    minY = Math.min(minY, vertex.y);
                                    maxY = Math.max(maxY, vertex.y);
                                    minZ = Math.min(minZ, vertex.z);
                                    maxZ = Math.max(maxZ, vertex.z);
                                }
                            }
                        }
                    });

                    const sizeX = maxX - minX;
                    const sizeY = maxY - minY;
                    const sizeZ = maxZ - minZ;

                    PLANE_DIMS = {
                        wingspan: sizeX / 2,        // Half of full width
                        length: sizeZ,              // Full length
                        height: sizeY,              // Full height
                        fuselageRadius: Math.min(sizeX, sizeY) / 4  // Tighter fuselage radius
                    };

                    console.log('âœ… F22 model loaded successfully from:', path);
                    console.log('ðŸ“ F22 Tight Bounding Box (from vertices):', {
                        fullWidth: sizeX.toFixed(2),
                        halfWingspan: PLANE_DIMS.wingspan.toFixed(2),
                        length: PLANE_DIMS.length.toFixed(2),
                        height: PLANE_DIMS.height.toFixed(2),
                        fuselageRadius: PLANE_DIMS.fuselageRadius.toFixed(2),
                        vertexRange: {
                            x: `${minX.toFixed(2)} to ${maxX.toFixed(2)}`,
                            y: `${minY.toFixed(2)} to ${maxY.toFixed(2)}`,
                            z: `${minZ.toFixed(2)} to ${maxZ.toFixed(2)}`
                        }
                    });

                    modelLoaded = true;
                    break;
                } catch (error) {
                    console.log('âŒ Failed to load from', path, ':', error.message);
                    // Try next path
                    continue;
                }
            }

            // If no model loaded, use simple delta wing fallback
            if (!modelLoaded) {
                console.log('âš ï¸ F22 model not found or failed to load, using simple delta wing fallback');
                console.log('ðŸ“ Make sure these files are in the assets folder:');
                console.log('   - f22.gltf (or f22.glb)');
                console.log('   - scene.bin (if using .gltf format)');
                console.log('   - Any texture files (.jpg, .png) referenced by the model');
                const fallbackPlane = createSimpleDeltaWing();
                aircraftGroup.add(fallbackPlane);
            }

            aircraftGroup.position.set(0, 25, 0);
            aircraft = aircraftGroup;
            scene.add(aircraftGroup);
        }

        function createCanyonSegment(zPosition) {
            const segment = new THREE.Group();
            segment.userData.zPosition = zPosition;

            const resolution = CONFIG.lodLevel;

            // Get canyon center for this segment
            const segmentCenterZ = zPosition - CONFIG.segmentLength / 2;
            const canyonCenterX = getCanyonCenter(segmentCenterZ);
            const crossSection = getCrossSectionShape(segmentCenterZ);
            const widthMultiplier = getCanyonWidthMultiplier(segmentCenterZ);
            const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;

            // Create canyon geometry with varying cross-section
            const leftWallGeo = new THREE.BufferGeometry();
            const rightWallGeo = new THREE.BufferGeometry();
            const floorGeo = new THREE.BufferGeometry();

            const segResZ = resolution;
            const segResY = Math.floor(resolution / 2);
            const segResX = resolution;

            // Generate wall vertices
            const leftVerts = [];
            const rightVerts = [];
            const floorVerts = [];
            const floorColors = [];
            const leftNormals = [];
            const rightNormals = [];
            const floorNormals = [];

            // Create walls with varying angle based on cross-section
            for (let iz = 0; iz <= segResZ; iz++) {
                const zFrac = iz / segResZ;
                const z = zPosition - zFrac * CONFIG.segmentLength;
                const localCenterX = getCanyonCenter(z);
                const localCrossSection = getCrossSectionShape(z);
                const localWidthMult = getCanyonWidthMultiplier(z);
                const localHalfWidth = (CONFIG.canyonWidth / 2) * localWidthMult;
                const localRimHeight = getCanyonRimHeight(z);

                for (let iy = 0; iy <= segResY; iy++) {
                    const yFrac = iy / segResY;
                    const y = yFrac * localRimHeight;

                    // Wall angle: V-shape has angled walls, U-shape has more vertical walls
                    // But never perfectly vertical
                    const baseAngle = 0.15 + localCrossSection * 0.6; // 0.15 to 0.75
                    const wallAngle = baseAngle + noise.fbm(z * 0.01, y * 0.02, 3) * 0.1;

                    // At the top, walls extend outward/back so player can't see the edge
                    let topExtension = 0;
                    if (yFrac > 0.7) {
                        // Smoothly extend walls outward near the top
                        const extendFrac = (yFrac - 0.7) / 0.3;
                        topExtension = extendFrac * extendFrac * 60; // Quadratic curve outward
                    }

                    // Left wall X position (wall leans inward at bottom for V, straighter for U)
                    const leftBaseX = localCenterX - localHalfWidth + (1 - yFrac) * localHalfWidth * (1 - wallAngle) - topExtension;

                    // Scale fractal detail with LOD: more octaves = more crinkly detail
                    // LOD controls octave count for deeper fractality, not spike size
                    const octaves = Math.max(3, Math.min(CONFIG.lodLevel, 16));  // Higher octave range for more detail
                    const leftDisplacement = noise.fbm(z * 0.01, y * 0.05, octaves, 0.5, 2.0) * 12;  // Constant displacement magnitude
                    const leftX = leftBaseX - leftDisplacement;

                    // Right wall X position
                    const rightBaseX = localCenterX + localHalfWidth - (1 - yFrac) * localHalfWidth * (1 - wallAngle) + topExtension;
                    const rightDisplacement = noise.fbm(z * 0.01 + 100, y * 0.05, octaves, 0.5, 2.0) * 12;  // Same constant displacement
                    const rightX = rightBaseX + rightDisplacement;

                    leftVerts.push(leftX, y, z);
                    rightVerts.push(rightX, y, z);
                }
            }

            // Create floor with varying shape
            for (let iz = 0; iz <= segResZ; iz++) {
                const zFrac = iz / segResZ;
                const z = zPosition - zFrac * CONFIG.segmentLength;
                const localCenterX = getCanyonCenter(z);
                const localCrossSection = getCrossSectionShape(z);
                const localWidthMult = getCanyonWidthMultiplier(z);
                const localHalfWidth = (CONFIG.canyonWidth / 2) * localWidthMult;

                for (let ix = 0; ix <= segResX; ix++) {
                    const xFrac = ix / segResX;
                    const localX = (xFrac - 0.5) * CONFIG.canyonWidth * localWidthMult;
                    const x = localCenterX + localX;

                    // Floor shape: V has pointed bottom, U has flatter bottom
                    const distFromCenter = Math.abs(localX) / (localHalfWidth);

                    // River channel
                    const riverWidth = 0.15;
                    let height;

                    if (distFromCenter < riverWidth) {
                        // River bed - below raised river level (water area)
                        height = 0 - noise.fbm(z * 0.02, x * 0.1, 3) * 0.5;
                        // Blue reflective water color
                        floorColors.push(0.1, 0.5, 1.0); // RGB for water
                    } else {
                        // Floor rises from center
                        // V-shape: steep rise, U-shape: gradual then steep
                        const uShapeFloor = Math.pow(distFromCenter, 0.5) * 8;
                        const vShapeFloor = distFromCenter * 15;
                        const baseHeight = vShapeFloor * (1 - localCrossSection) + uShapeFloor * localCrossSection;

                        // Add fractal detail - floor is never perfectly flat
                        // LOD controls detail level through octaves, not spike size
                        const octaves = Math.max(3, Math.min(CONFIG.lodLevel, 16));  // Higher octave range for more detail
                        const detail = noise.fbm(z * 0.01, x * 0.02, octaves, 0.5, 2.0) * 4;  // Constant displacement
                        height = baseHeight + detail;
                        // Brown rock color
                        floorColors.push(0.4, 0.26, 0.13); // RGB for rock
                    }

                    floorVerts.push(x, height, z);
                }
            }

            // Create indices for walls
            const leftIndices = [];
            const rightIndices = [];
            for (let iz = 0; iz < segResZ; iz++) {
                for (let iy = 0; iy < segResY; iy++) {
                    const a = iz * (segResY + 1) + iy;
                    const b = a + 1;
                    const c = a + (segResY + 1);
                    const d = c + 1;

                    leftIndices.push(a, b, c);
                    leftIndices.push(b, d, c);

                    rightIndices.push(a, c, b);
                    rightIndices.push(b, c, d);
                }
            }

            // Create indices for floor
            const floorIndices = [];
            for (let iz = 0; iz < segResZ; iz++) {
                for (let ix = 0; ix < segResX; ix++) {
                    const a = iz * (segResX + 1) + ix;
                    const b = a + 1;
                    const c = a + (segResX + 1);
                    const d = c + 1;

                    floorIndices.push(a, c, b);
                    floorIndices.push(b, c, d);
                }
            }

            // Set geometry attributes
            leftWallGeo.setAttribute('position', new THREE.Float32BufferAttribute(leftVerts, 3));
            leftWallGeo.setIndex(leftIndices);
            leftWallGeo.computeVertexNormals();

            rightWallGeo.setAttribute('position', new THREE.Float32BufferAttribute(rightVerts, 3));
            rightWallGeo.setIndex(rightIndices);
            rightWallGeo.computeVertexNormals();

            floorGeo.setAttribute('position', new THREE.Float32BufferAttribute(floorVerts, 3));
            floorGeo.setAttribute('color', new THREE.Float32BufferAttribute(floorColors, 3));
            floorGeo.setIndex(floorIndices);
            floorGeo.computeVertexNormals();

            // Materials - smooth shading lets fractal geometry and lighting do the work
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide,
                fog: true
            });

            // Floor material with vertex colors (blue for water, brown for rock)
            const floorMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.3,
                metalness: 0.7,
                vertexColors: true,
                envMapIntensity: 1.5,
                fog: true
            });

            // Create meshes
            const leftWall = new THREE.Mesh(leftWallGeo, wallMaterial);
            leftWall.receiveShadow = true;
            leftWall.castShadow = true;
            segment.add(leftWall);

            const rightWall = new THREE.Mesh(rightWallGeo, wallMaterial);
            rightWall.receiveShadow = true;
            rightWall.castShadow = true;
            segment.add(rightWall);

            const floor = new THREE.Mesh(floorGeo, floorMaterial);
            floor.receiveShadow = true;
            segment.add(floor);

            // Add rings randomly (only if frequency > 0)
            if (CONFIG.ringFrequency > 0 && Math.random() < CONFIG.ringFrequency / 10) {
                createRing(segment, zPosition, canyonCenterX);
            }

            scene.add(segment);
            canyonSegments.push(segment);

            return segment;
        }

        function createRing(parent, zPosition, canyonCenterX) {
            const ringGeo = new THREE.TorusGeometry(12, 0.4, 8, 24);  // Thinner tube: 0.4 instead of 1.0
            const ringMat = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,  // White
                transparent: true,
                opacity: 0.6,
                emissive: 0xCCCCCC,
                emissiveIntensity: 0.2
            });

            const ring = new THREE.Mesh(ringGeo, ringMat);

            // Random position within canyon bounds, centered on canyon path
            const z = zPosition - Math.random() * CONFIG.segmentLength;
            const localCenterX = getCanyonCenter(z);
            const x = localCenterX + (Math.random() - 0.5) * (CONFIG.canyonWidth - 40);
            const y = 15 + Math.random() * (CONFIG.canyonHeight - 60);

            ring.position.set(x, y, z);

            // Apply rotation based on config setting
            // (by default torus hole points up along Y axis)
            switch (CONFIG.ringRotationAxis) {
                case 'x':
                    ring.rotation.x = Math.PI / 2;
                    break;
                case 'y':
                    ring.rotation.y = Math.PI / 2;
                    break;
                case 'z':
                    ring.rotation.z = Math.PI / 2;
                    break;
                case 'xy':
                    ring.rotation.x = Math.PI / 2;
                    ring.rotation.y = Math.PI / 2;
                    break;
                case 'xz':
                    ring.rotation.x = Math.PI / 2;
                    ring.rotation.z = Math.PI / 2;
                    break;
                case 'yz':
                    ring.rotation.y = Math.PI / 2;
                    ring.rotation.z = Math.PI / 2;
                    break;
            }

            ring.userData.isRing = true;
            ring.userData.collected = false;

            parent.add(ring);
            rings.push(ring);
        }

        function createInitialCanyon() {
            for (let i = 0; i < CONFIG.visibleSegments; i++) {
                const z = -i * CONFIG.segmentLength;
                createCanyonSegment(z);
                lastSegmentZ = z;
            }
        }

        function spawnEnemy() {
            if (!CONFIG.enemiesEnabled) return;

            const enemyGroup = new THREE.Group();

            // Simple enemy plane
            const bodyGeo = new THREE.ConeGeometry(1, 4, 6);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            enemyGroup.add(body);

            const wingGeo = new THREE.BoxGeometry(6, 0.1, 1.2);
            const wingMat = new THREE.MeshPhongMaterial({ color: 0xaa0000 });
            const wings = new THREE.Mesh(wingGeo, wingMat);
            enemyGroup.add(wings);

            // Position enemy ahead of player, following canyon path
            const z = playerZ - 300 - Math.random() * 200;
            const canyonCenterX = getCanyonCenter(z);
            const x = canyonCenterX + (Math.random() - 0.5) * (CONFIG.canyonWidth - 30);
            const y = 15 + Math.random() * 50;

            enemyGroup.position.set(x, y, z);
            enemyGroup.userData.health = 30;
            enemyGroup.userData.lastShot = 0;

            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }

        function createBullet(position, direction, isEnemy = false) {
            const bulletGeo = new THREE.SphereGeometry(0.3, 4, 4);
            const bulletMat = new THREE.MeshBasicMaterial({
                color: isEnemy ? 0xff0000 : 0x00ff00
            });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);

            bullet.position.copy(position);
            bullet.userData.direction = direction.clone();
            bullet.userData.speed = isEnemy ? 300 : 450; // 3x faster
            bullet.userData.velocity = direction.clone().multiplyScalar(bullet.userData.speed);
            bullet.userData.isEnemy = isEnemy;

            scene.add(bullet);

            if (isEnemy) {
                enemyBullets.push(bullet);
            } else {
                bullets.push(bullet);
            }
        }

        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key.toLowerCase() === 'p') {
                    paused = !paused;
                }

                if (e.key === ' ') {
                    e.preventDefault();
                    shootBullet();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Settings controls
            document.getElementById('apply-settings').addEventListener('click', applySettings);
            document.getElementById('restart-btn').addEventListener('click', restartGame);
            document.getElementById('replay-btn').addEventListener('click', replayGame);

            // Value display updates
            document.getElementById('canyon-lod').addEventListener('input', (e) => {
                document.getElementById('lod-value').textContent = e.target.value;
            });

            document.getElementById('ring-frequency').addEventListener('input', (e) => {
                document.getElementById('ring-freq-value').textContent = e.target.value;
            });

            document.getElementById('flight-speed').addEventListener('input', (e) => {
                document.getElementById('speed-value').textContent = e.target.value;
            });

            document.getElementById('enemy-difficulty').addEventListener('input', (e) => {
                document.getElementById('enemy-diff-value').textContent = e.target.value;
            });

            document.getElementById('replay-backtrack').addEventListener('input', (e) => {
                document.getElementById('replay-backtrack-value').textContent = e.target.value;
            });
        }

        function shootBullet() {
            if (gameOver) return;

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(aircraft.quaternion);

            const bulletPos = aircraft.position.clone();
            bulletPos.add(direction.clone().multiplyScalar(3));

            createBullet(bulletPos, direction);
        }

        function applySettings() {
            CONFIG.timeOfDay = document.getElementById('time-of-day').value;
            CONFIG.lodLevel = parseInt(document.getElementById('canyon-lod').value);
            CONFIG.ringFrequency = parseInt(document.getElementById('ring-frequency').value);
            CONFIG.ringRotationAxis = document.getElementById('ring-rotation-axis').value;
            CONFIG.flightSpeed = parseFloat(document.getElementById('flight-speed').value);
            CONFIG.autopilotMode = document.getElementById('autopilot-mode').value;
            CONFIG.enemiesEnabled = document.getElementById('enemies-enabled').checked;
            CONFIG.enemyDifficulty = parseInt(document.getElementById('enemy-difficulty').value);
            CONFIG.visualDebugging = document.getElementById('visual-debugging').checked;
            CONFIG.replayBacktrackDistance = parseInt(document.getElementById('replay-backtrack').value);
            CONFIG.rerollCanyonOnRestart = document.getElementById('reroll-canyon').checked;

            // Update lighting and skybox
            updateSkybox();
            setupLighting();

            // Regenerate canyon with new LOD and ring settings
            regenerateCanyon();
        }

        function regenerateCanyon() {
            // Clear existing segments
            canyonSegments.forEach(segment => scene.remove(segment));
            canyonSegments = [];
            rings = [];

            // Recreate
            const currentZ = Math.floor(playerZ / CONFIG.segmentLength) * CONFIG.segmentLength;
            for (let i = 0; i < CONFIG.visibleSegments; i++) {
                const z = currentZ - i * CONFIG.segmentLength;
                createCanyonSegment(z);
                lastSegmentZ = z;
            }
        }

        function restartGame() {
            // Reset state
            score = 0;
            ringsCollected = 0;
            health = 100;
            gameOver = false;
            playerZ = 0;
            pitch = 0;
            roll = 0;
            yaw = 0;

            // Reset aircraft
            aircraft.position.set(0, 25, 0);
            aircraft.rotation.set(0, 0, 0);

            // Clear enemies and bullets
            enemies.forEach(e => scene.remove(e));
            bullets.forEach(b => scene.remove(b));
            enemyBullets.forEach(b => scene.remove(b));
            enemies = [];
            bullets = [];
            enemyBullets = [];

            // Clear state history
            stateHistory.length = 0;
            crashState = null;

            // Re-roll canyon if enabled
            if (CONFIG.rerollCanyonOnRestart) {
                // Recreate noise generators with new random seeds
                const newSeed1 = Math.floor(Math.random() * 2147483647);
                const newSeed2 = Math.floor(Math.random() * 2147483647);
                noise = new SimplexNoise(newSeed1);
                pathNoise = new SimplexNoise(newSeed2);
                console.log("Canyon re-rolled with new seeds:", newSeed1, newSeed2);
            }

            // Regenerate canyon
            regenerateCanyon();

            // Update UI
            updateHUD();
            document.getElementById('game-over').style.display = 'none';
        }

        function replayGame() {
            if (!crashState || stateHistory.length === 0) {
                console.log("No crash state or history available for replay");
                return;
            }

            // Find the state that's backtrack distance before the crash
            const backtrackDistance = CONFIG.replayBacktrackDistance;
            let replayState = null;

            // Search backwards through history to find state N units before crash
            for (let i = stateHistory.length - 1; i >= 0; i--) {
                const state = stateHistory[i];
                const distanceFromCrash = crashState.playerZ - state.playerZ;
                if (distanceFromCrash >= backtrackDistance) {
                    replayState = state;
                    break;
                }
            }

            // If not found (history not long enough), use earliest state
            if (!replayState && stateHistory.length > 0) {
                replayState = stateHistory[0];
            }

            if (!replayState) {
                console.log("No suitable replay state found");
                return;
            }

            console.log(`Replaying from ${backtrackDistance} units before crash`);

            // Restore state
            score = replayState.score;
            health = replayState.health;
            gameOver = false;
            playerZ = replayState.playerZ;
            pitch = replayState.pitch;
            roll = replayState.roll;
            yaw = replayState.yaw;

            // Restore aircraft position and rotation
            aircraft.position.copy(replayState.position);
            aircraft.quaternion.copy(replayState.quaternion);

            // Clear enemies and bullets
            enemies.forEach(e => scene.remove(e));
            bullets.forEach(b => scene.remove(b));
            enemyBullets.forEach(b => scene.remove(b));
            enemies = [];
            bullets = [];
            enemyBullets = [];

            // Keep the state history up to the replay point
            const replayIndex = stateHistory.indexOf(replayState);
            if (replayIndex >= 0) {
                stateHistory.length = replayIndex + 1;
            }

            // Enable visual debugging and set speed to 0.5x for replay
            CONFIG.visualDebugging = true;
            CONFIG.flightSpeed = 0.5;
            document.getElementById('visual-debugging').checked = true;
            document.getElementById('flight-speed').value = 0.5;
            document.getElementById('speed-value').textContent = '0.5';

            // Regenerate visible canyon segments around current position
            regenerateCanyon();

            // Update UI
            updateHUD();
            document.getElementById('game-over').style.display = 'none';
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('rings-collected').textContent = ringsCollected;
            document.getElementById('health').textContent = Math.max(0, health);
        }

        function checkCollisions() {
            const playerPos = aircraft.position;
            const canyonCenterX = getCanyonCenter(playerPos.z);
            const crossSection = getCrossSectionShape(playerPos.z);
            const widthMultiplier = getCanyonWidthMultiplier(playerPos.z);
            const rimHeight = getCanyonRimHeight(playerPos.z);

            // Calculate local position relative to canyon center
            const localX = playerPos.x - canyonCenterX;
            const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;

            // Calculate wingtip positions using proper quaternion transformation
            // Left wingtip in local coordinates (positive X direction)
            const leftLocalPos = new THREE.Vector3(PLANE_DIMS.wingspan, 0, 0);
            leftLocalPos.applyQuaternion(aircraft.quaternion);
            const leftWingtip = playerPos.clone().add(leftLocalPos);

            // Right wingtip in local coordinates (negative X direction)
            const rightLocalPos = new THREE.Vector3(-PLANE_DIMS.wingspan, 0, 0);
            rightLocalPos.applyQuaternion(aircraft.quaternion);
            const rightWingtip = playerPos.clone().add(rightLocalPos);

            const leftWingtipX = leftWingtip.x;
            const leftWingtipY = leftWingtip.y;
            const rightWingtipX = rightWingtip.x;
            const rightWingtipY = rightWingtip.y;

            // Wall collision - check fuselage and both wingtips
            const yFrac = playerPos.y / rimHeight;
            const baseAngle = 0.15 + crossSection * 0.6;
            const effectiveHalfWidth = halfWidth - (1 - yFrac) * halfWidth * (1 - baseAngle);

            // Check fuselage collision (tight box)
            if (Math.abs(localX) > effectiveHalfWidth - PLANE_DIMS.fuselageRadius) {
                triggerDeath();
                return;
            }

            // Check left wingtip collision
            const leftWingtipLocalX = leftWingtipX - canyonCenterX;
            const leftWingtipYFrac = leftWingtipY / rimHeight;
            const leftWingtipEffectiveWidth = halfWidth - (1 - leftWingtipYFrac) * halfWidth * (1 - baseAngle);
            if (Math.abs(leftWingtipLocalX) > leftWingtipEffectiveWidth - 2) {
                triggerDeath();
                return;
            }

            // Check right wingtip collision
            const rightWingtipLocalX = rightWingtipX - canyonCenterX;
            const rightWingtipYFrac = rightWingtipY / rimHeight;
            const rightWingtipEffectiveWidth = halfWidth - (1 - rightWingtipYFrac) * halfWidth * (1 - baseAngle);
            if (Math.abs(rightWingtipLocalX) > rightWingtipEffectiveWidth - 2) {
                triggerDeath();
                return;
            }

            // Floor collision - account for V/U shape and raised river
            // Use tight collision for fuselage bottom
            const distFromCenter = Math.abs(localX) / halfWidth;
            const uShapeFloor = Math.pow(distFromCenter, 0.5) * 8;
            const vShapeFloor = distFromCenter * 15;
            const baseFloorHeight = vShapeFloor * (1 - crossSection) + uShapeFloor * crossSection;
            // River is at level 2, add tighter safety margin
            const floorHeight = Math.max(baseFloorHeight, 2) + 3;  // Tighter: 3 instead of 5

            if (playerPos.y < floorHeight) {
                triggerDeath();
                return;
            }

            // Check if wingtips hit floor (when rolled)
            if (leftWingtipY < 2 || rightWingtipY < 2) {
                triggerDeath();
                return;
            }

            // Ceiling (canyon rim) - cap below the lowest possible rim
            const lowestRim = CONFIG.canyonHeight - 100; // Lowest rim is base - 100
            if (playerPos.y > lowestRim - 10) {
                aircraft.position.y = lowestRim - 10;
            }

            // Ring collection
            rings.forEach((ring, index) => {
                if (!ring.userData.collected) {
                    const worldPos = new THREE.Vector3();
                    ring.getWorldPosition(worldPos);

                    if (playerPos.distanceTo(worldPos) < 14) {  // Increased for larger rings
                        ring.userData.collected = true;
                        ring.visible = false;
                        score += 100;
                        ringsCollected++;
                        updateHUD();
                    }
                }
            });

            // Enemy bullets hitting player
            enemyBullets.forEach((bullet, index) => {
                if (playerPos.distanceTo(bullet.position) < 2) {
                    health -= 10;
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                    updateHUD();

                    if (health <= 0) {
                        triggerDeath();
                    }
                }
            });

            // Player bullets hitting enemies
            bullets.forEach((bullet, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (bullet.position.distanceTo(enemy.position) < 3) {
                        enemy.userData.health -= 20;
                        scene.remove(bullet);
                        bullets.splice(bIndex, 1);

                        if (enemy.userData.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(eIndex, 1);
                            score += 200;
                            updateHUD();
                        }
                    }
                });
            });
        }

        function triggerDeath() {
            gameOver = true;

            // Save crash state for replay
            crashState = {
                position: aircraft.position.clone(),
                quaternion: aircraft.quaternion.clone(),
                pitch: pitch,
                roll: roll,
                yaw: yaw,
                playerZ: playerZ,
                score: score,
                health: health,
                flightSpeed: CONFIG.flightSpeed
            };

            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
        }

        function updateAircraft(delta) {
            // Emergency wing collision avoidance - check straight ahead from wingtips
            let emergencyRollLeft = false;
            let emergencyRollRight = false;

            // Short-range wing collision detection (looking straight ahead)
            const wingLookAhead = 30;  // Short distance ahead
            const forwardDir = new THREE.Vector3(0, 0, -1);
            forwardDir.applyQuaternion(aircraft.quaternion);

            // Get wingtip positions
            const leftWingLocal = new THREE.Vector3(PLANE_DIMS.wingspan, 0, 0);
            leftWingLocal.applyQuaternion(aircraft.quaternion);
            const leftWingtip = aircraft.position.clone().add(leftWingLocal);

            const rightWingLocal = new THREE.Vector3(-PLANE_DIMS.wingspan, 0, 0);
            rightWingLocal.applyQuaternion(aircraft.quaternion);
            const rightWingtip = aircraft.position.clone().add(rightWingLocal);

            // Check nose straight ahead
            const noseCheckPos = aircraft.position.clone().add(forwardDir.clone().multiplyScalar(wingLookAhead));
            const noseWalls = getActualWallPositions(noseCheckPos.z, noseCheckPos.y);
            const noseClearance = 5;
            const noseHitsWall = (noseCheckPos.x - noseClearance < noseWalls.leftWall) ||
                                 (noseCheckPos.x + noseClearance > noseWalls.rightWall);

            // Check left wing straight ahead
            const leftWingCheckPos = leftWingtip.clone().add(forwardDir.clone().multiplyScalar(wingLookAhead));
            const leftWingWalls = getActualWallPositions(leftWingCheckPos.z, leftWingCheckPos.y);
            const wingClearance = 3;
            const leftWingHitsWall = (leftWingCheckPos.x - wingClearance < leftWingWalls.leftWall) ||
                                     (leftWingCheckPos.x + wingClearance > leftWingWalls.rightWall);

            // Check right wing straight ahead
            const rightWingCheckPos = rightWingtip.clone().add(forwardDir.clone().multiplyScalar(wingLookAhead));
            const rightWingWalls = getActualWallPositions(rightWingCheckPos.z, rightWingCheckPos.y);
            const rightWingHitsWall = (rightWingCheckPos.x - wingClearance < rightWingWalls.leftWall) ||
                                      (rightWingCheckPos.x + wingClearance > rightWingWalls.rightWall);

            // If nose is clear but wing will hit, roll violently to raise that wing
            if (!noseHitsWall && leftWingHitsWall) {
                emergencyRollLeft = true;  // Roll left to raise left wing
            }
            if (!noseHitsWall && rightWingHitsWall) {
                emergencyRollRight = true;  // Roll right to raise right wing
            }

            // Look ahead to follow the optimal path
            const lookAheadDistance = 150;
            const targetZ = aircraft.position.z - lookAheadDistance;

            // Autopilot modes
            if (CONFIG.autopilotMode === 'alpha') {
                // ALPHA MODE: Follow optimal flight path
                // Get optimal path position at look-ahead point
                const optimalPos = getOptimalFlightPath(targetZ, aircraft.position.x);

                // Get canyon boundaries for wall awareness
                const canyonCenterX = getCanyonCenter(targetZ);
                const widthMultiplier = getCanyonWidthMultiplier(targetZ);
                const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;
                const leftWall = canyonCenterX - halfWidth;
                const rightWall = canyonCenterX + halfWidth;

                // Calculate offsets from optimal path
                const offsetX = aircraft.position.x - optimalPos.x;
                const offsetY = aircraft.position.y - optimalPos.y;

                // Check distance to walls for emergency avoidance
                const distToLeftWall = aircraft.position.x - leftWall;
                const distToRightWall = rightWall - aircraft.position.x;
                const safeDistance = 25; // Trigger avoidance when within 25 units of wall

                // User input modifies roll (2x faster: 4 instead of 2)
                if (keys['a']) roll = Math.max(roll - 4 * delta, -2.1);  // 120 degrees
                else if (keys['d']) roll = Math.min(roll + 4 * delta, 2.1);   // 120 degrees
                else if (emergencyRollLeft) {
                    // Emergency: roll left violently to raise left wing
                    roll = Math.max(roll - 8 * delta, -Math.PI / 2);  // Violent roll left
                } else if (emergencyRollRight) {
                    // Emergency: roll right violently to raise right wing
                    roll = Math.min(roll + 8 * delta, Math.PI / 2);  // Violent roll right
                } else {
                    // Determine desired roll based on situation
                    let targetRoll = 0;

                    // Plane dimensions for wingtip clearance
                    const wingspan = PLANE_DIMS.wingspan;  // Half-wingspan from model
                    const wingClearance = 8;  // Extra clearance needed

                    // Calculate required clearance for different roll angles
                    // At 0 degrees (level): need full wingspan clearance horizontally
                    // At 90 degrees (knife-edge): need minimal horizontal clearance
                    const levelWingspan = wingspan + wingClearance;

                    // Check if we need to roll to fit through narrow section
                    const availableWidth = Math.min(distToLeftWall, distToRightWall);
                    const needsKnifeEdge = availableWidth < levelWingspan;

                    // Emergency wall avoidance - takes priority
                    if (distToLeftWall < safeDistance) {
                        // Too close to left wall
                        if (needsKnifeEdge) {
                            // Roll to knife-edge to reduce horizontal profile
                            targetRoll = Math.PI / 2;  // 90 degrees (vertical)
                        } else {
                            // Roll right to move away from wall
                            targetRoll = Math.PI / 2;  // 90 degrees right
                        }
                    } else if (distToRightWall < safeDistance) {
                        // Too close to right wall
                        if (needsKnifeEdge) {
                            // Roll to knife-edge to reduce horizontal profile
                            targetRoll = Math.PI / 2;  // 90 degrees (vertical)
                        } else {
                            // Roll left to move away from wall
                            targetRoll = -Math.PI / 2;  // 90 degrees left
                        }
                    } else {
                        // Normal path following
                        // Check if canyon ahead is narrow
                        if (needsKnifeEdge) {
                            // Canyon is narrow - go knife-edge (90 degrees)
                            targetRoll = Math.PI / 2;
                        } else if (Math.abs(offsetX) > 10) {
                            // Large offset - use 90-degree bank for efficient turn
                            targetRoll = offsetX > 0 ? -Math.PI / 2 : Math.PI / 2;
                        } else if (Math.abs(offsetX) > 2) {
                            // Medium offset - use proportional roll
                            targetRoll = THREE.MathUtils.clamp(-offsetX * 0.05, -1.5, 1.5);
                        } else {
                            // Small offset - level out for stability
                            targetRoll = 0;
                        }
                    }

                    roll = THREE.MathUtils.lerp(roll, targetRoll, delta * 5);
                }

                // Pitch control - altitude management + coordinated turns
                if (keys['w']) pitch = Math.max(pitch - 2 * delta, -0.8);
                else if (keys['s']) pitch = Math.min(pitch + 2 * delta, 0.8);
                else {
                    // Coordinated turn: when rolled, pitch up to turn
                    // At 90Â° bank, all pitch goes into turning (not climbing)
                    // At 0Â° bank, all pitch goes into altitude change
                    const rollMagnitude = Math.abs(roll);
                    let turnPitch = 0;

                    if (rollMagnitude > 0.1) {  // If significantly rolled
                        // Need to pitch up proportional to roll to maintain level turn
                        // More roll = more pitch needed
                        turnPitch = rollMagnitude * 0.6;  // Base turn pitch
                    }

                    // Auto-pitch for altitude management (reduced when banked)
                    const heightError = optimalPos.y - aircraft.position.y;
                    // Reduce altitude correction authority when banked (busy turning)
                    const altitudeAuthority = 1.0 - (rollMagnitude / Math.PI) * 0.7;  // Less authority when banked
                    const altitudePitch = THREE.MathUtils.clamp(heightError * 0.05, -0.5, 0.5) * altitudeAuthority;

                    // Combine turn pitch and altitude pitch
                    const desiredPitch = turnPitch + altitudePitch;
                    const clampedPitch = THREE.MathUtils.clamp(desiredPitch, -0.8, 0.8);
                    pitch = THREE.MathUtils.lerp(pitch, clampedPitch, delta * 5);
                }
            } else if (CONFIG.autopilotMode === 'beta') {
                // BETA MODE: Find longest straight path without crashing

                // Check if we need to sample (every 2 plane lengths = 24 units)
                const sampleInterval = PLANE_DIMS.length * 2;  // 24 units
                let shouldSample = false;

                if (!betaLastSamplePos) {
                    // First sample
                    shouldSample = true;
                    betaLastSamplePos = aircraft.position.clone();
                    console.log("Beta autopilot: First sample at position", aircraft.position);
                } else {
                    // Check distance traveled
                    const distanceTraveled = aircraft.position.distanceTo(betaLastSamplePos);
                    if (distanceTraveled >= sampleInterval) {
                        shouldSample = true;
                        betaLastSamplePos = aircraft.position.clone();
                        console.log("Beta autopilot: Sampling after", distanceTraveled, "units");
                    }
                }

                if (shouldSample) {
                    // Clean up old red debug lines (every sample)
                    betaDebugRedLines.forEach(line => scene.remove(line));
                    betaDebugRedLines = [];

                    // Clean up old spheres if debugging is disabled
                    if (!CONFIG.visualDebugging) {
                        betaDebugSphereBatches.forEach(batch => {
                            batch.forEach(sphere => scene.remove(sphere));
                        });
                        betaDebugSphereBatches = [];
                        betaDebugGreenLines.forEach(line => scene.remove(line));
                        betaDebugGreenLines = [];
                    }

                    // Store the position where we're sampling from
                    const samplingOrigin = aircraft.position.clone();
                    const samplingY = aircraft.position.y;  // Lock to current elevation

                    // Test parameters - narrow cone for incremental steering
                    const numSamples = 9;  // Test specific angles: 0, Â±0.5, Â±1, Â±1.5, Â±2 degrees
                    const maxAngleDegrees = 2;  // Â±2 degrees
                    const maxAngle = maxAngleDegrees * Math.PI / 180;
                    const stepSize = 3;  // Step 3 units at a time (smaller for better accuracy)

                    let bestDistance = 0;
                    let straightAheadDistance = 0;  // Track straight-ahead path distance
                    let bestAngle = 0;  // Track the angle of the best path
                    const samplePaths = [];  // Store all sample paths with their endpoints

                    // Generate specific test angles (not random)
                    const testAngles = [0];  // Start with straight ahead
                    for (let deg = 0.5; deg <= maxAngleDegrees; deg += 0.5) {
                        testAngles.push(deg * Math.PI / 180);   // Right
                        testAngles.push(-deg * Math.PI / 180);  // Left
                    }
                    // Always add wider angle samples for immediate aggressive banking detection
                    testAngles.push(5 * Math.PI / 180);   // +5Â° right
                    testAngles.push(-5 * Math.PI / 180);  // -5Â° left
                    testAngles.push(10 * Math.PI / 180);  // +10Â° right (very aggressive)
                    testAngles.push(-10 * Math.PI / 180); // -10Â° left (very aggressive)

                    // Generate 2D directions (horizontal fan at current elevation)
                    for (let i = 0; i < testAngles.length; i++) {
                        const angle = testAngles[i];

                        // Create 2D direction (X, Z plane, constant Y)
                        const testDir = new THREE.Vector3(
                            Math.sin(angle),
                            0,  // No vertical component - stay at current elevation
                            -Math.cos(angle)
                        ).normalize();

                        // Extend ray until collision
                        let distanceTraveled = 0;
                        let collision = false;
                        let testPos = samplingOrigin.clone();
                        let lastValidPos = samplingOrigin.clone();
                        let stepCount = 0;

                        while (!collision && distanceTraveled < 1000) {
                            // Step forward
                            testPos.add(testDir.clone().multiplyScalar(stepSize));
                            distanceTraveled += stepSize;
                            stepCount++;

                            // Get actual wall positions at this (z, y) coordinate
                            const testZ = testPos.z;
                            const testY = testPos.y;  // Use actual Y position for height-aware wall calculation
                            const wallPositions = getActualWallPositions(testZ, testY);
                            const leftWall = wallPositions.leftWall;
                            const rightWall = wallPositions.rightWall;

                            // Account for plane wingspan (half-wingspan on each side)
                            const clearance = PLANE_DIMS.wingspan + 8;  // Wingspan + larger safety margin
                            const leftWingtip = testPos.x - clearance;
                            const rightWingtip = testPos.x + clearance;

                            // Debug first sample only
                            if (i === 0 && stepCount <= 3) {
                                console.log(`Sample 0, Step ${stepCount}: pos=(${testPos.x.toFixed(1)}, ${testPos.y.toFixed(1)}, ${testPos.z.toFixed(1)}), walls=[${leftWall.toFixed(1)}, ${rightWall.toFixed(1)}], wingtips=[${leftWingtip.toFixed(1)}, ${rightWingtip.toFixed(1)}]`);
                            }

                            // Check if plane (with wingspan) would hit the canyon walls
                            if (leftWingtip < leftWall || rightWingtip > rightWall) {
                                collision = true;
                                // Use the last valid position before collision
                                testPos = lastValidPos.clone();
                                if (i === 0) {
                                    console.log(`Sample 0: COLLISION at step ${stepCount}, distance ${distanceTraveled}, endpoint at (${testPos.x.toFixed(1)}, ${testPos.y.toFixed(1)}, ${testPos.z.toFixed(1)})`);
                                }
                            } else {
                                // This position is valid, save it
                                lastValidPos = testPos.clone();
                            }

                            // Check if we're out of vertical bounds
                            const lowestRim = CONFIG.canyonHeight - 100;
                            if (testPos.y < 8 || testPos.y > lowestRim - 10) {
                                collision = true;
                            }
                        }

                        if (i === 0 && !collision) {
                            console.log(`Sample 0: Hit 1000 unit limit, no collision detected`);
                        }

                        // Store this sample path
                        samplePaths.push({
                            direction: testDir,
                            distance: distanceTraveled,
                            endpoint: testPos.clone(),
                            angle: angle
                        });

                        // If this is the straight-ahead sample (i === 0), save its distance
                        if (i === 0) {
                            straightAheadDistance = distanceTraveled;
                        }

                        // If this direction is better, save it
                        if (distanceTraveled > bestDistance) {
                            bestDistance = distanceTraveled;
                            betaBestDirection = testDir.clone();
                            bestAngle = angle;
                        }
                    }

                    // Extended search: If best angle is at the edge, keep searching in that direction
                    const edgeThreshold = 0.9; // 90% of max angle is considered "at edge"
                    const maxAngleRad = maxAngleDegrees * Math.PI / 180;
                    const isAtEdge = Math.abs(bestAngle) >= maxAngleRad * edgeThreshold;

                    if (isAtEdge) {
                        console.log(`Best sample is at edge (${(bestAngle * 180 / Math.PI).toFixed(2)}Â°), extending search...`);

                        // Determine search direction (left or right)
                        const searchDirection = bestAngle > 0 ? 1 : -1;  // 1 = right, -1 = left
                        const angleStep = 0.5 * Math.PI / 180;  // 0.5 degree steps
                        let currentSearchAngle = bestAngle + (searchDirection * angleStep);
                        let keepSearching = true;
                        let maxExtendedAngle = 45 * Math.PI / 180;  // Don't go beyond Â±45 degrees

                        while (keepSearching && Math.abs(currentSearchAngle) <= maxExtendedAngle) {
                            const testDir = new THREE.Vector3(
                                Math.sin(currentSearchAngle),
                                0,
                                -Math.cos(currentSearchAngle)
                            ).normalize();

                            // Test this angle
                            let distanceTraveled = 0;
                            let collision = false;
                            let testPos = samplingOrigin.clone();
                            let lastValidPos = samplingOrigin.clone();

                            while (!collision && distanceTraveled < 1000) {
                                testPos.add(testDir.clone().multiplyScalar(stepSize));
                                distanceTraveled += stepSize;

                                const wallPositions = getActualWallPositions(testPos.z, testPos.y);
                                const clearance = PLANE_DIMS.wingspan + 8;
                                const leftWingtip = testPos.x - clearance;
                                const rightWingtip = testPos.x + clearance;

                                if (leftWingtip < wallPositions.leftWall || rightWingtip > wallPositions.rightWall) {
                                    collision = true;
                                    testPos = lastValidPos.clone();
                                } else {
                                    lastValidPos = testPos.clone();
                                }

                                const lowestRim = CONFIG.canyonHeight - 100;
                                if (testPos.y < 8 || testPos.y > lowestRim - 10) {
                                    collision = true;
                                }
                            }

                            // Store this extended sample
                            samplePaths.push({
                                direction: testDir,
                                distance: distanceTraveled,
                                endpoint: testPos.clone(),
                                angle: currentSearchAngle
                            });

                            // Check if this is better
                            if (distanceTraveled > bestDistance) {
                                console.log(`Extended sample at ${(currentSearchAngle * 180 / Math.PI).toFixed(2)}Â° is better: ${distanceTraveled.toFixed(1)} > ${bestDistance.toFixed(1)}`);
                                bestDistance = distanceTraveled;
                                betaBestDirection = testDir.clone();
                                bestAngle = currentSearchAngle;
                                // Keep searching
                                currentSearchAngle += (searchDirection * angleStep);
                            } else {
                                // This sample is worse, we found the peak
                                console.log(`Extended sample at ${(currentSearchAngle * 180 / Math.PI).toFixed(2)}Â° is worse: ${distanceTraveled.toFixed(1)} <= ${bestDistance.toFixed(1)}, stopping search`);
                                keepSearching = false;
                            }
                        }

                        console.log(`Extended search complete, final best angle: ${(bestAngle * 180 / Math.PI).toFixed(2)}Â°`);
                    }

                    // Create debug visualization for all sample paths (red lines + collision spheres)
                    if (CONFIG.visualDebugging) {
                        const newSphereBatch = [];  // New batch for this sample

                        for (let i = 0; i < samplePaths.length; i++) {
                            const sample = samplePaths[i];
                            const isBestSample = betaBestDirection && sample.direction.equals(betaBestDirection);

                            const points = [samplingOrigin, sample.endpoint];
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                            const lineMaterial = new THREE.LineBasicMaterial({
                                color: 0xff0000,  // Red for all samples
                                opacity: 0.3,
                                transparent: true
                            });

                            const line = new THREE.Line(lineGeometry, lineMaterial);
                            scene.add(line);
                            betaDebugRedLines.push(line);

                            // Add sphere at collision point - green for best, red for others
                            const sphereGeometry = new THREE.SphereGeometry(3, 8, 8);  // Radius 3
                            const sphereMaterial = new THREE.MeshBasicMaterial({
                                color: isBestSample ? 0x00ff00 : 0xff0000,  // Green for best, red for others
                                transparent: true,
                                opacity: 0.6
                            });
                            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                            sphere.position.copy(sample.endpoint);
                            scene.add(sphere);
                            newSphereBatch.push(sphere);
                        }

                        // Add this batch to our collection
                        betaDebugSphereBatches.push(newSphereBatch);

                        // Keep only last 2 batches
                        if (betaDebugSphereBatches.length > 2) {
                            const oldBatch = betaDebugSphereBatches.shift();
                            oldBatch.forEach(sphere => scene.remove(sphere));
                        }

                        console.log("Beta autopilot: Created", newSphereBatch.length, "collision spheres");
                        console.log("Total sphere batches:", betaDebugSphereBatches.length);
                        if (newSphereBatch.length > 0) {
                            console.log("First sphere at:", newSphereBatch[0].position);
                        }
                    }

                    // Store distances and angle for use in steering logic
                    betaBestDistance = bestDistance;
                    betaStraightAheadDistance = straightAheadDistance;
                    betaBestAngle = bestAngle;
                    console.log(`Beta: Straight-ahead=${straightAheadDistance.toFixed(1)}, Best=${bestDistance.toFixed(1)}, BestAngle=${(bestAngle * 180 / Math.PI).toFixed(2)}Â°, Improvement=${((bestDistance/straightAheadDistance - 1) * 100).toFixed(1)}%`);

                    // Create green line for best direction
                    if (CONFIG.visualDebugging && betaBestDirection) {
                        // Find the endpoint for the best direction
                        const bestSample = samplePaths.find(s => s.direction.equals(betaBestDirection));
                        if (bestSample) {
                            const points = [samplingOrigin, bestSample.endpoint];
                            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                            const lineMaterial = new THREE.LineBasicMaterial({
                                color: 0x00ff00,  // Green
                                linewidth: 3,  // Note: linewidth > 1 only works with WebGL line rendering
                                opacity: 0.9,
                                transparent: true
                            });

                            const greenLine = new THREE.Line(lineGeometry, lineMaterial);
                            scene.add(greenLine);
                            betaDebugGreenLines.push(greenLine);

                            // Keep only last 2 green samples
                            if (betaDebugGreenLines.length > 2) {
                                const oldLine = betaDebugGreenLines.shift();
                                scene.remove(oldLine);
                            }
                        }
                    }
                }

                // Incremental steering using narrow cone sampling
                // User input always takes priority
                if (keys['a']) roll = Math.max(roll - 4 * delta, -2.1);
                else if (keys['d']) roll = Math.min(roll + 4 * delta, 2.1);
                else if (emergencyRollLeft) {
                    // Emergency: roll left violently to raise left wing
                    roll = Math.max(roll - 8 * delta, -Math.PI / 2);  // Violent roll left
                } else if (emergencyRollRight) {
                    // Emergency: roll right violently to raise right wing
                    roll = Math.min(roll + 8 * delta, Math.PI / 2);  // Violent roll right
                } else {
                    // Only steer if we have valid sampling data
                    if (betaStraightAheadDistance > 0) {
                        // Only adjust if best path is better than straight ahead
                        const improvementThreshold = 1.02;  // 2% improvement threshold
                        if (betaBestDistance > betaStraightAheadDistance * improvementThreshold) {
                            // Steer incrementally toward the best angle
                            // Use the angle directly (positive = right, negative = left)
                            // Adaptive steering gain: more aggressive for larger angles
                            const bestAngleDegrees = Math.abs(betaBestAngle * 180 / Math.PI);
                            let steeringGain;
                            let maxRoll;

                            if (bestAngleDegrees <= 2) {
                                // Small corrections: moderate roll
                                steeringGain = 15;
                                maxRoll = Math.PI / 4;  // Â±45 degrees
                            } else if (bestAngleDegrees <= 10) {
                                // Medium corrections: more aggressive
                                steeringGain = 8;
                                maxRoll = Math.PI / 2;  // Â±90 degrees (knife-edge)
                            } else {
                                // Large corrections: very aggressive
                                steeringGain = 4;
                                maxRoll = Math.PI / 2;  // Â±90 degrees (knife-edge)
                            }

                            const targetRoll = betaBestAngle * steeringGain;
                            const clampedTargetRoll = THREE.MathUtils.clamp(targetRoll, -maxRoll, maxRoll);

                            // Smooth interpolation to target roll
                            roll = THREE.MathUtils.lerp(roll, clampedTargetRoll, delta * 3);
                        } else {
                            // Straight ahead is best - level out
                            roll = THREE.MathUtils.lerp(roll, 0, delta * 3);
                        }
                    } else {
                        // No valid data yet - level out
                        roll = THREE.MathUtils.lerp(roll, 0, delta * 3);
                    }
                }

                // User input modifies pitch
                if (keys['w']) pitch = Math.max(pitch - 2 * delta, -0.8);
                else if (keys['s']) pitch = Math.min(pitch + 2 * delta, 0.8);
                else {
                    // Coordinated turn: pitch based on roll
                    const rollMagnitude = Math.abs(roll);
                    let turnPitch = rollMagnitude * 0.5;  // Moderate pitch for coordinated turn
                    const clampedPitch = THREE.MathUtils.clamp(turnPitch, 0, 0.6);
                    pitch = THREE.MathUtils.lerp(pitch, clampedPitch, delta * 3);
                }
            } else {
                // Manual control without autopilot
                if (keys['w']) pitch = Math.max(pitch - 2 * delta, -0.8);
                else if (keys['s']) pitch = Math.min(pitch + 2 * delta, 0.8);
                else pitch *= 0.95;  // Decay pitch when not actively controlling

                // 2x faster roll: 4 instead of 2, 120-degree limit: 2.1 instead of 1.0
                if (keys['a']) roll = Math.max(roll - 4 * delta, -2.1);
                else if (keys['d']) roll = Math.min(roll + 4 * delta, 2.1);
                else if (emergencyRollLeft) {
                    // Emergency: roll left violently to raise left wing
                    roll = Math.max(roll - 8 * delta, -Math.PI / 2);  // Violent roll left
                } else if (emergencyRollRight) {
                    // Emergency: roll right violently to raise right wing
                    roll = Math.min(roll + 8 * delta, Math.PI / 2);  // Violent roll right
                } else roll *= 0.95;  // Decay roll when not actively controlling

                // Don't accumulate yaw - it causes spinning
                yaw *= 0.98;  // Slowly decay yaw
            }

            // Apply rotations using quaternions for proper local-axis rotation
            // Order: Roll first, then pitch around the rolled axis
            const qRoll = new THREE.Quaternion();
            qRoll.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -roll);

            const qPitch = new THREE.Quaternion();
            qPitch.setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch);

            const qYaw = new THREE.Quaternion();
            qYaw.setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

            // Combine rotations: Yaw * Roll * Pitch
            aircraft.quaternion.copy(qYaw);
            aircraft.quaternion.multiply(qRoll);
            aircraft.quaternion.multiply(qPitch);

            // Calculate direction the nose is pointing
            const noseDirection = new THREE.Vector3(0, 0, -1);
            noseDirection.applyQuaternion(aircraft.quaternion);

            // Move ONLY in the direction the nose is pointing
            const speed = 50 * CONFIG.flightSpeed * delta;
            const movement = noseDirection.multiplyScalar(speed);
            aircraft.position.add(movement);

            // Clamp vertical position only
            const lowestRim = CONFIG.canyonHeight - 100;
            aircraft.position.y = Math.max(8, Math.min(lowestRim - 10, aircraft.position.y));

            playerZ = aircraft.position.z;

            // Capture state for replay system (rolling buffer)
            if (!gameOver) {
                const currentState = {
                    position: aircraft.position.clone(),
                    quaternion: aircraft.quaternion.clone(),
                    pitch: pitch,
                    roll: roll,
                    yaw: yaw,
                    playerZ: playerZ,
                    score: score,
                    health: health,
                    flightSpeed: CONFIG.flightSpeed
                };
                stateHistory.push(currentState);
                // Keep buffer size limited
                if (stateHistory.length > maxHistorySize) {
                    stateHistory.shift();
                }
            }

            // Update camera to follow aircraft (not canyon)
            camera.position.x = aircraft.position.x;
            camera.position.y = aircraft.position.y + 5;
            camera.position.z = aircraft.position.z + 25;

            // Look ahead in the direction the plane is facing
            const cameraLookAhead = 50;
            const lookTarget = aircraft.position.clone();
            lookTarget.z -= cameraLookAhead;

            camera.lookAt(lookTarget);
        }

        function updateCanyon() {
            // Remove old segments and add new ones
            const playerSegment = Math.floor(-playerZ / CONFIG.segmentLength);

            // Create new segments ahead
            while (-lastSegmentZ < -playerZ + CONFIG.visibleSegments * CONFIG.segmentLength) {
                lastSegmentZ -= CONFIG.segmentLength;
                createCanyonSegment(lastSegmentZ);
            }

            // Remove segments behind
            canyonSegments = canyonSegments.filter(segment => {
                if (segment.userData.zPosition > playerZ + CONFIG.segmentLength * 2) {
                    scene.remove(segment);
                    return false;
                }
                return true;
            });

            // Clean up old rings
            rings = rings.filter(ring => {
                const worldPos = new THREE.Vector3();
                ring.getWorldPosition(worldPos);
                return worldPos.z < playerZ + 100;
            });
        }

        function updateEnemies(delta) {
            if (!CONFIG.enemiesEnabled) return;

            // Spawn new enemies
            if (Math.random() < 0.005 * CONFIG.enemyDifficulty && enemies.length < 5) {
                spawnEnemy();
            }

            const now = Date.now();

            enemies.forEach((enemy, index) => {
                // Move enemy towards player
                const toPlayer = aircraft.position.clone().sub(enemy.position);
                toPlayer.normalize();

                // Enemy movement
                enemy.position.add(toPlayer.multiplyScalar(20 * delta));
                enemy.lookAt(aircraft.position);

                // Enemy shooting
                const shootInterval = 2000 - CONFIG.enemyDifficulty * 150;
                if (now - enemy.userData.lastShot > shootInterval) {
                    const direction = aircraft.position.clone().sub(enemy.position).normalize();
                    createBullet(enemy.position.clone(), direction, true);
                    enemy.userData.lastShot = now;
                }

                // Remove if too far behind
                if (enemy.position.z > playerZ + 100) {
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                }
            });
        }

        function updateBullets(delta) {
            const gravity = 30; // Bullet drop

            // Player bullets
            bullets.forEach((bullet, index) => {
                // Apply velocity
                bullet.position.add(
                    bullet.userData.velocity.clone().multiplyScalar(delta)
                );

                // Apply gravity (bullet drop)
                bullet.userData.velocity.y -= gravity * delta;

                // Remove if too far
                if (bullet.position.distanceTo(aircraft.position) > 500) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            // Enemy bullets
            enemyBullets.forEach((bullet, index) => {
                // Apply velocity
                bullet.position.add(
                    bullet.userData.velocity.clone().multiplyScalar(delta)
                );

                // Apply gravity (bullet drop)
                bullet.userData.velocity.y -= gravity * delta;

                // Remove if too far
                if (bullet.position.distanceTo(aircraft.position) > 300) {
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                }
            });
        }

        // Animation loop
        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (!gameOver && !paused) {
                updateAircraft(delta);
                updateCanyon();
                updateEnemies(delta);
                updateBullets(delta);
                updateLightingPosition();
                updateDebugLines();
                updateDebugCircles();
                updateCollisionBoxDebug();
                checkCollisions();
            }

            // Update skybox position to follow player
            const skybox = scene.getObjectByName('skybox');
            if (skybox && aircraft) {
                skybox.position.copy(aircraft.position);
            }

            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
