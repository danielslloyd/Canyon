<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canyon Flight</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        #hud div {
            margin-bottom: 8px;
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            max-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #controls-panel h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 8px;
        }

        #controls-panel label {
            display: block;
            margin: 8px 0 4px;
        }

        #controls-panel input[type="range"] {
            width: 100%;
        }

        #controls-panel select, #controls-panel button {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            border-radius: 4px;
            border: none;
        }

        #controls-panel button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            margin-top: 10px;
        }

        #controls-panel button:hover {
            background: #45a049;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .checkbox-container input {
            margin-right: 8px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 12px;
            color: white;
            text-align: center;
            display: none;
        }

        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff4444;
        }

        #game-over p {
            font-size: 20px;
            margin-bottom: 20px;
        }

        #game-over button {
            padding: 12px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            text-align: center;
        }

        .value-display {
            color: #88ff88;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Rings: <span id="rings-collected">0</span></div>
            <div>Health: <span id="health">100</span></div>
        </div>

        <div id="controls-panel">
            <h3>Settings</h3>

            <label>Time of Day:</label>
            <select id="time-of-day">
                <option value="morning" selected>Morning (Fog)</option>
                <option value="noon">Noon</option>
                <option value="sunset">Sunset</option>
            </select>

            <label>Canyon Detail (LOD): <span id="lod-value" class="value-display">12</span></label>
            <input type="range" id="canyon-lod" min="2" max="20" value="12">

            <label>Ring Frequency: <span id="ring-freq-value" class="value-display">3</span></label>
            <input type="range" id="ring-frequency" min="0" max="10" value="3">

            <label>Ring Rotation Axis:</label>
            <select id="ring-rotation-axis">
                <option value="x">X-axis</option>
                <option value="y">Y-axis</option>
                <option value="z" selected>Z-axis (default)</option>
                <option value="xy">X+Y axes</option>
                <option value="xz">X+Z axes</option>
                <option value="yz">Y+Z axes</option>
            </select>

            <label>Flight Speed: <span id="speed-value" class="value-display">1.5</span>x</label>
            <input type="range" id="flight-speed" min="0.5" max="3" step="0.1" value="1.5">

            <div class="checkbox-container">
                <input type="checkbox" id="stabilization-enabled" checked>
                <label for="stabilization-enabled">Auto-stabilization</label>
            </div>

            <div class="checkbox-container">
                <input type="checkbox" id="enemies-enabled">
                <label for="enemies-enabled">Enable Enemy Planes</label>
            </div>

            <label>Enemy Difficulty: <span id="enemy-diff-value" class="value-display">5</span></label>
            <input type="range" id="enemy-difficulty" min="1" max="10" value="5">

            <button id="apply-settings">Apply Settings</button>
        </div>

        <div id="game-over">
            <h2>CRASHED!</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="restart-btn">Restart</button>
        </div>

        <div id="instructions">
            <strong>Controls:</strong> W/S - Pitch | A/D - Roll | Space - Shoot | P - Pause
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Game Configuration
        const CONFIG = {
            canyonWidth: 120,
            canyonHeight: 200,
            canyonDepth: 2000,
            segmentLength: 100,
            visibleSegments: 25,
            lodLevel: 12,
            ringFrequency: 3,
            ringRotationAxis: 'z',  // Z-axis is correct
            flightSpeed: 1.5,
            enemiesEnabled: false,
            enemyDifficulty: 5,
            timeOfDay: 'morning',
            stabilizationEnabled: true
        };

        // Game State
        let score = 0;
        let ringsCollected = 0;
        let health = 100;
        let gameOver = false;
        let paused = false;

        // Three.js components
        // This work is based on "F22 (Remaster)" (https://sketchfab.com/3d-models/f22-remaster-bf6df655e73e4d4b9deac6cfee85564c) by CreaDX (https://sketchfab.com/CreaDX) licensed under CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
        let scene, camera, renderer;
        let aircraft, aircraftGroup;
        let canyonSegments = [];
        let rings = [];
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let autopilotPathLine = null;
        let canyonCenterLine = null;
        let optimalPathLine = null;
        let debugPitchCircle = null;
        let debugRollCircle = null;
        let debugTravelArrow = null;
        let debugNoseArrow = null;

        // Controls
        const keys = {};
        let pitch = 0;
        let roll = 0;
        let yaw = 0;
        let lastCanyonOffset = 0;

        // Position tracking
        let playerZ = 0;
        let lastSegmentZ = 0;

        // Canyon path - stores the center X position at each Z
        const canyonPath = new Map();

        // Noise function for fractal terrain
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;

                // Shuffle
                let n, q;
                for (let i = 255; i > 0; i--) {
                    n = Math.floor((seed = (seed * 16807) % 2147483647) / 2147483647 * (i + 1));
                    q = this.p[i];
                    this.p[i] = this.p[n];
                    this.p[n] = q;
                }

                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1))
                );
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            // Fractal Brownian Motion for more detailed terrain
            fbm(x, y, octaves = 6, persistence = 0.5, lacunarity = 2.0) {
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    value += amplitude * this.noise2D(x * frequency, y * frequency);
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }

                return value / maxValue;
            }
        }

        const noise = new SimplexNoise(12345);
        const pathNoise = new SimplexNoise(67890);

        // Get canyon center position at a given Z
        function getCanyonCenter(z) {
            // Create pronounced S-curves with varying radius and angle
            // Primary large S-curves
            const curve1 = pathNoise.noise2D(z * 0.0015, 0) * 80;
            // Secondary curves for variation in turn radius
            const curve2 = pathNoise.noise2D(z * 0.004, 100) * 40;
            // Tertiary detail curves
            const curve3 = pathNoise.noise2D(z * 0.01, 200) * 15;
            // Extra variation in turn sharpness
            const curve4 = Math.sin(z * 0.002 + pathNoise.noise2D(z * 0.001, 300) * 2) * 50;

            return curve1 + curve2 + curve3 + curve4;
        }

        // Get cross-section shape factor (0 = V-shape, 1 = U-shape)
        function getCrossSectionShape(z) {
            return (pathNoise.noise2D(z * 0.005, 500) + 1) / 2;
        }

        // Get canyon width multiplier (varies between 1x and 2x)
        function getCanyonWidthMultiplier(z) {
            return 1.0 + (pathNoise.noise2D(z * 0.003, 700) + 1) / 2;
        }

        // Get canyon rim height variation (dramatic variation)
        function getCanyonRimHeight(z) {
            // Base height + dramatic variation
            const base = CONFIG.canyonHeight;
            const variation = pathNoise.noise2D(z * 0.004, 900) * 200; // +/- 200 units (2x max height)
            return base + variation;
        }

        // Calculate optimal flight path that takes the straightest safe route
        // Returns {x, y} position at given z
        function getOptimalFlightPath(z, currentX = 0) {
            const centerX = getCanyonCenter(z);
            const widthMultiplier = getCanyonWidthMultiplier(z);
            const canyonWidth = CONFIG.canyonWidth * widthMultiplier;
            const halfWidth = canyonWidth / 2;

            // Account for plane wingspan when calculating safe bounds
            const wingspan = 24;  // Half-wingspan
            const safetyMargin = 10;  // Additional safety buffer
            const requiredClearance = wingspan + safetyMargin;

            // Calculate safe flight corridor
            const leftWall = centerX - halfWidth;
            const rightWall = centerX + halfWidth;
            const leftBound = leftWall + requiredClearance;
            const rightBound = rightWall - requiredClearance;

            // Straightest path strategy: minimize lateral movement
            // Only deviate from current path when necessary for safety
            let targetX = currentX;

            // Check if current position is safe
            if (currentX < leftBound) {
                // Too close to left wall - must move right
                targetX = leftBound;
            } else if (currentX > rightBound) {
                // Too close to right wall - must move left
                targetX = rightBound;
            } else {
                // Current position is safe
                // Prefer to continue straight, but gently drift toward center for optimal positioning
                // This ensures we're centered for upcoming turns while minimizing unnecessary movement
                const distToCenter = centerX - currentX;

                // Only move toward center if we're far from it
                if (Math.abs(distToCenter) > 15) {
                    // Gentle pull toward center (5% correction per step)
                    targetX = currentX + distToCenter * 0.05;
                } else {
                    // Close enough to center - hold current position for straightest path
                    targetX = currentX;
                }

                // Ensure we stay in safe bounds
                targetX = Math.max(leftBound, Math.min(rightBound, targetX));
            }

            // Target height: middle of flight envelope for maximum clearance
            const floorHeight = 8; // Safe floor height from collision detection
            const ceilingHeight = CONFIG.canyonHeight - 110; // Safe ceiling
            const targetY = (floorHeight + ceilingHeight) / 2; // Middle altitude

            return { x: targetX, y: targetY };
        }

        // Initialize the game
        async function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 10, 30);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Create game elements
            createSkybox();
            setupLighting();
            await createAircraft();  // Wait for aircraft to load
            createInitialCanyon();

            // Event listeners
            setupEventListeners();

            // Start game loop
            animate();
        }

        function createSkybox() {
            updateSkybox();
        }

        function updateSkybox(centerOnPlayer = false) {
            // Remove old skybox
            const oldSkybox = scene.getObjectByName('skybox');
            if (oldSkybox) scene.remove(oldSkybox);

            let skyColors;
            switch (CONFIG.timeOfDay) {
                case 'morning':
                    skyColors = {
                        top: new THREE.Color(0x87CEEB),
                        bottom: new THREE.Color(0xFFE4B5)
                    };
                    break;
                case 'noon':
                    skyColors = {
                        top: new THREE.Color(0x0077FF),
                        bottom: new THREE.Color(0x87CEEB)
                    };
                    break;
                case 'sunset':
                    skyColors = {
                        top: new THREE.Color(0x1a0533),
                        bottom: new THREE.Color(0xFF6B35)
                    };
                    break;
            }

            // Set up fog for morning
            if (CONFIG.timeOfDay === 'morning') {
                // Exponential fog that follows camera automatically (reduced density)
                scene.fog = new THREE.FogExp2(0xD8E8E8, 0.0015);
            } else {
                scene.fog = null;
            }

            // Gradient sky sphere
            const skyGeo = new THREE.SphereGeometry(2000, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: THREE.UniformsUtils.merge([
                    THREE.UniformsLib.fog,
                    {
                        topColor: { value: skyColors.top },
                        bottomColor: { value: skyColors.bottom },
                        offset: { value: 400 },
                        exponent: { value: 0.6 }
                    }
                ]),
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide,
                fog: true
            });

            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = 'skybox';

            // Center on player if requested
            if (centerOnPlayer && aircraft) {
                sky.position.copy(aircraft.position);
            }

            scene.add(sky);
        }


        let sunLight, sunVisual;

        function setupLighting() {
            // Remove old lights and sun visual
            scene.children = scene.children.filter(child =>
                !(child instanceof THREE.Light) && child.name !== 'sunVisual'
            );
            sunLight = null;
            sunVisual = null;

            // Ambient light
            let ambientIntensity, ambientColor;
            let sunPosition, sunColor, sunIntensity;

            switch (CONFIG.timeOfDay) {
                case 'morning':
                    ambientIntensity = 0.4;
                    ambientColor = 0xB0C4DE;
                    sunPosition = new THREE.Vector3(100, 30, -100);
                    sunColor = 0xFFE4C4;
                    sunIntensity = 1.0;
                    break;
                case 'noon':
                    // Harsh directional light for noon
                    ambientIntensity = 0.2;
                    ambientColor = 0xFFFFFF;
                    sunPosition = new THREE.Vector3(0, 200, -50);
                    sunColor = 0xFFFFFF;
                    sunIntensity = 2.5;
                    break;
                case 'sunset':
                    ambientIntensity = 0.3;
                    ambientColor = 0xFF8C69;
                    sunPosition = new THREE.Vector3(-200, 20, -100);
                    sunColor = 0xFF4500;
                    sunIntensity = 1.2;
                    break;
            }

            const ambient = new THREE.AmbientLight(ambientColor, ambientIntensity);
            scene.add(ambient);

            // Directional light (sun)
            sunLight = new THREE.DirectionalLight(sunColor, sunIntensity);
            sunLight.position.copy(sunPosition);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -150;
            sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150;
            sunLight.shadow.camera.bottom = -150;
            sunLight.userData.initialPosition = sunPosition.clone();
            scene.add(sunLight);

            // Add sun visual for sunset
            if (CONFIG.timeOfDay === 'sunset') {
                const sunGeo = new THREE.SphereGeometry(30, 32, 32);
                const sunMat = new THREE.MeshBasicMaterial({
                    color: 0xFF6600,
                    transparent: true,
                    opacity: 0.9
                });
                sunVisual = new THREE.Mesh(sunGeo, sunMat);
                sunVisual.position.copy(sunPosition).multiplyScalar(5);
                sunVisual.name = 'sunVisual';
                sunVisual.userData.initialPosition = sunVisual.position.clone();
                scene.add(sunVisual);
            }
        }

        function updateLightingPosition() {
            if (sunLight && aircraft) {
                const offset = sunLight.userData.initialPosition;
                sunLight.position.copy(aircraft.position).add(offset);
                sunLight.target.position.copy(aircraft.position);
                sunLight.target.updateMatrixWorld();
            }
            if (sunVisual && aircraft) {
                const offset = sunVisual.userData.initialPosition;
                sunVisual.position.copy(aircraft.position).add(offset);
            }
        }

        function updateDebugArrows(travelDirection) {
            if (!aircraft) return;

            // Remove old arrows
            if (debugTravelArrow) {
                scene.remove(debugTravelArrow);
            }
            if (debugNoseArrow) {
                scene.remove(debugNoseArrow);
            }

            // Arrow showing actual direction of travel (GREEN)
            const travelDir = travelDirection.clone().normalize();
            const arrowOrigin = aircraft.position.clone();
            arrowOrigin.add(new THREE.Vector3(0, 0, -10).applyQuaternion(aircraft.quaternion)); // Front of plane
            debugTravelArrow = new THREE.ArrowHelper(
                travelDir,
                arrowOrigin,
                15,  // length
                0x00FF00,  // green
                3,  // head length
                2   // head width
            );
            scene.add(debugTravelArrow);

            // Arrow showing nose direction (RED)
            const noseDir = new THREE.Vector3(0, 0, -1);
            noseDir.applyQuaternion(aircraft.quaternion);
            debugNoseArrow = new THREE.ArrowHelper(
                noseDir,
                arrowOrigin,
                15,  // length
                0xFF0000,  // red
                3,  // head length
                2   // head width
            );
            scene.add(debugNoseArrow);
        }

        function updateDebugCircles() {
            if (!aircraft) return;

            // Remove old circles
            if (debugPitchCircle) {
                scene.remove(debugPitchCircle);
            }
            if (debugRollCircle) {
                scene.remove(debugRollCircle);
            }

            // Calculate bounding sphere radius for the plane
            const planeRadius = 8;  // Approximate radius for visualization

            // Create pitch axis circle (RED) - rotation around X-axis (lateral)
            // This circle is in the YZ plane of the plane's local coordinate system
            const pitchPoints = [];
            const segments = 64;
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                // Circle in local YZ plane (perpendicular to X-axis)
                const localPoint = new THREE.Vector3(
                    0,  // No X component - perpendicular to X-axis
                    Math.cos(theta) * planeRadius,
                    Math.sin(theta) * planeRadius
                );
                // Transform to world space using plane's rotation
                localPoint.applyQuaternion(aircraft.quaternion);
                localPoint.add(aircraft.position);
                pitchPoints.push(localPoint);
            }

            const pitchGeometry = new THREE.BufferGeometry().setFromPoints(pitchPoints);
            const pitchMaterial = new THREE.LineBasicMaterial({
                color: 0xFF0000,  // Red
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            debugPitchCircle = new THREE.Line(pitchGeometry, pitchMaterial);
            scene.add(debugPitchCircle);

            // Create roll axis circle (BLUE) - rotation around Z-axis (longitudinal)
            // This circle is in the XY plane of the plane's local coordinate system
            const rollPoints = [];
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                // Circle in local XY plane (perpendicular to Z-axis)
                const localPoint = new THREE.Vector3(
                    Math.cos(theta) * planeRadius,
                    Math.sin(theta) * planeRadius,
                    0  // No Z component - perpendicular to Z-axis (forward)
                );
                // Transform to world space using plane's rotation
                localPoint.applyQuaternion(aircraft.quaternion);
                localPoint.add(aircraft.position);
                rollPoints.push(localPoint);
            }

            const rollGeometry = new THREE.BufferGeometry().setFromPoints(rollPoints);
            const rollMaterial = new THREE.LineBasicMaterial({
                color: 0x0000FF,  // Blue
                linewidth: 3,
                transparent: true,
                opacity: 0.8
            });
            debugRollCircle = new THREE.Line(rollGeometry, rollMaterial);
            scene.add(debugRollCircle);
        }

        function updateDebugLines() {
            if (!aircraft) return;

            // Remove old lines
            if (autopilotPathLine) {
                scene.remove(autopilotPathLine);
            }
            if (canyonCenterLine) {
                scene.remove(canyonCenterLine);
            }
            if (optimalPathLine) {
                scene.remove(optimalPathLine);
            }

            const startZ = aircraft.position.z + 50;  // Start a bit behind
            const endZ = aircraft.position.z - 800;   // Extend far ahead
            const step = 10;

            // Purple line: Canyon center at fixed height (old autopilot reference)
            const targetHeight = 30;
            const autopilotPoints = [];
            for (let z = startZ; z >= endZ; z -= step) {
                const centerX = getCanyonCenter(z);
                autopilotPoints.push(new THREE.Vector3(centerX, targetHeight, z));
            }

            const autopilotGeometry = new THREE.BufferGeometry().setFromPoints(autopilotPoints);
            const autopilotMaterial = new THREE.LineDashedMaterial({
                color: 0xFF00FF,      // Purple/magenta
                linewidth: 5,
                scale: 1,
                dashSize: 5,
                gapSize: 3
            });

            autopilotPathLine = new THREE.Line(autopilotGeometry, autopilotMaterial);
            autopilotPathLine.computeLineDistances();
            scene.add(autopilotPathLine);

            // Green line: Canyon center at plane's current height
            const canyonCenterPoints = [];
            for (let z = startZ; z >= endZ; z -= step) {
                const centerX = getCanyonCenter(z);
                canyonCenterPoints.push(new THREE.Vector3(centerX, aircraft.position.y, z));
            }

            const canyonCenterGeometry = new THREE.BufferGeometry().setFromPoints(canyonCenterPoints);
            const canyonCenterMaterial = new THREE.LineDashedMaterial({
                color: 0x00FF00,      // Green
                linewidth: 5,
                scale: 1,
                dashSize: 5,
                gapSize: 3
            });

            canyonCenterLine = new THREE.Line(canyonCenterGeometry, canyonCenterMaterial);
            canyonCenterLine.computeLineDistances();
            scene.add(canyonCenterLine);

            // Blue line: Optimal flight path (straightest path in middle third)
            const optimalPathPoints = [];
            let currentX = aircraft.position.x;
            for (let z = startZ; z >= endZ; z -= step) {
                const optimalPos = getOptimalFlightPath(z, currentX);
                optimalPathPoints.push(new THREE.Vector3(optimalPos.x, optimalPos.y, z));
                currentX = optimalPos.x; // Track for next iteration
            }

            const optimalGeometry = new THREE.BufferGeometry().setFromPoints(optimalPathPoints);
            const optimalMaterial = new THREE.LineDashedMaterial({
                color: 0x0088FF,      // Blue
                linewidth: 5,
                scale: 1,
                dashSize: 5,
                gapSize: 3
            });

            optimalPathLine = new THREE.Line(optimalGeometry, optimalMaterial);
            optimalPathLine.computeLineDistances();
            scene.add(optimalPathLine);
        }

        function createSimpleDeltaWing() {
            // Simple, clean delta wing fighter
            const group = new THREE.Group();

            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0x6B7280,
                flatShading: true
            });

            // Fuselage (simple elongated diamond shape)
            const fuselageGeo = new THREE.ConeGeometry(0.5, 4, 4);
            const fuselage = new THREE.Mesh(fuselageGeo, bodyMat);
            fuselage.rotation.x = -Math.PI / 2;
            fuselage.castShadow = true;
            group.add(fuselage);

            // Delta wing (single swept wing)
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);      // Center front
            wingShape.lineTo(-4, 2);     // Left tip
            wingShape.lineTo(0, 1.5);    // Back center
            wingShape.lineTo(4, 2);      // Right tip
            wingShape.lineTo(0, 0);      // Back to front

            const wingGeo = new THREE.ShapeGeometry(wingShape);
            const wing = new THREE.Mesh(wingGeo, bodyMat);
            wing.rotation.x = -Math.PI / 2;
            wing.position.y = -0.1;
            wing.castShadow = true;
            group.add(wing);

            // Single vertical stabilizer
            const tailGeo = new THREE.ConeGeometry(0.3, 1.2, 3);
            const tail = new THREE.Mesh(tailGeo, bodyMat);
            tail.position.y = 0.6;
            tail.position.z = 1.5;
            tail.castShadow = true;
            group.add(tail);

            // Cockpit
            const canopyGeo = new THREE.SphereGeometry(0.3, 8, 8);
            const canopyMat = new THREE.MeshPhongMaterial({
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.7
            });
            const canopy = new THREE.Mesh(canopyGeo, canopyMat);
            canopy.position.z = -0.8;
            canopy.position.y = 0.2;
            canopy.scale.set(1, 0.8, 1.3);
            group.add(canopy);

            group.scale.set(1.5, 1.5, 1.5);
            return group;
        }

        async function createAircraft() {
            aircraftGroup = new THREE.Group();

            // Try to load F22 model from assets folder
            const loader = new GLTFLoader();
            const modelPaths = [
                './assets/f22.gltf',
                './assets/F22.gltf',
                './assets/f22.glb',
                './assets/F22.glb'
            ];

            let modelLoaded = false;

            for (const path of modelPaths) {
                try {
                    console.log('Attempting to load model from:', path);
                    const gltf = await loader.loadAsync(path);
                    const model = gltf.scene;

                    // Check if model has any meshes
                    let hasMeshes = false;
                    model.traverse((child) => {
                        if (child.isMesh) {
                            hasMeshes = true;
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    if (!hasMeshes) {
                        console.warn('Model loaded but contains no meshes:', path);
                        continue;
                    }

                    // Scale and orient the model
                    model.scale.set(4, 4, 4);  // 2x larger than before
                    // Rotate model: if left wing points forward and nose points right,
                    // we need -90¬∞ rotation to make nose point forward
                    model.rotation.y = -Math.PI / 2;

                    aircraftGroup.add(model);
                    modelLoaded = true;
                    console.log('‚úÖ F22 model loaded successfully from:', path);
                    break;
                } catch (error) {
                    console.log('‚ùå Failed to load from', path, ':', error.message);
                    // Try next path
                    continue;
                }
            }

            // If no model loaded, use simple delta wing fallback
            if (!modelLoaded) {
                console.log('‚ö†Ô∏è F22 model not found or failed to load, using simple delta wing fallback');
                console.log('üìÅ Make sure these files are in the assets folder:');
                console.log('   - f22.gltf (or f22.glb)');
                console.log('   - scene.bin (if using .gltf format)');
                console.log('   - Any texture files (.jpg, .png) referenced by the model');
                const fallbackPlane = createSimpleDeltaWing();
                aircraftGroup.add(fallbackPlane);
            }

            aircraftGroup.position.set(0, 25, 0);
            aircraft = aircraftGroup;
            scene.add(aircraftGroup);
        }

        function createCanyonSegment(zPosition) {
            const segment = new THREE.Group();
            segment.userData.zPosition = zPosition;

            const resolution = CONFIG.lodLevel;

            // Get canyon center for this segment
            const segmentCenterZ = zPosition - CONFIG.segmentLength / 2;
            const canyonCenterX = getCanyonCenter(segmentCenterZ);
            const crossSection = getCrossSectionShape(segmentCenterZ);
            const widthMultiplier = getCanyonWidthMultiplier(segmentCenterZ);
            const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;

            // Create canyon geometry with varying cross-section
            const leftWallGeo = new THREE.BufferGeometry();
            const rightWallGeo = new THREE.BufferGeometry();
            const floorGeo = new THREE.BufferGeometry();

            const segResZ = resolution;
            const segResY = Math.floor(resolution / 2);
            const segResX = resolution;

            // Generate wall vertices
            const leftVerts = [];
            const rightVerts = [];
            const floorVerts = [];
            const floorColors = [];
            const leftNormals = [];
            const rightNormals = [];
            const floorNormals = [];

            // Create walls with varying angle based on cross-section
            for (let iz = 0; iz <= segResZ; iz++) {
                const zFrac = iz / segResZ;
                const z = zPosition - zFrac * CONFIG.segmentLength;
                const localCenterX = getCanyonCenter(z);
                const localCrossSection = getCrossSectionShape(z);
                const localWidthMult = getCanyonWidthMultiplier(z);
                const localHalfWidth = (CONFIG.canyonWidth / 2) * localWidthMult;
                const localRimHeight = getCanyonRimHeight(z);

                for (let iy = 0; iy <= segResY; iy++) {
                    const yFrac = iy / segResY;
                    const y = yFrac * localRimHeight;

                    // Wall angle: V-shape has angled walls, U-shape has more vertical walls
                    // But never perfectly vertical
                    const baseAngle = 0.15 + localCrossSection * 0.6; // 0.15 to 0.75
                    const wallAngle = baseAngle + noise.fbm(z * 0.01, y * 0.02, 3) * 0.1;

                    // At the top, walls extend outward/back so player can't see the edge
                    let topExtension = 0;
                    if (yFrac > 0.7) {
                        // Smoothly extend walls outward near the top
                        const extendFrac = (yFrac - 0.7) / 0.3;
                        topExtension = extendFrac * extendFrac * 60; // Quadratic curve outward
                    }

                    // Left wall X position (wall leans inward at bottom for V, straighter for U)
                    const leftBaseX = localCenterX - localHalfWidth + (1 - yFrac) * localHalfWidth * (1 - wallAngle) - topExtension;

                    // Scale fractal detail with LOD: more octaves = more crinkly
                    // Base displacement scales with LOD level
                    const lodScale = Math.max(1, CONFIG.lodLevel / 6);  // Scale factor based on LOD
                    const octaves = Math.max(3, Math.min(CONFIG.lodLevel, 8));  // Use LOD as octave count
                    const leftDisplacement = noise.fbm(z * 0.01, y * 0.05, octaves, 0.5, 2.0) * (12 * lodScale);
                    const leftX = leftBaseX - leftDisplacement;

                    // Right wall X position
                    const rightBaseX = localCenterX + localHalfWidth - (1 - yFrac) * localHalfWidth * (1 - wallAngle) + topExtension;
                    const rightDisplacement = noise.fbm(z * 0.01 + 100, y * 0.05, octaves, 0.5, 2.0) * (12 * lodScale);
                    const rightX = rightBaseX + rightDisplacement;

                    leftVerts.push(leftX, y, z);
                    rightVerts.push(rightX, y, z);
                }
            }

            // Create floor with varying shape
            for (let iz = 0; iz <= segResZ; iz++) {
                const zFrac = iz / segResZ;
                const z = zPosition - zFrac * CONFIG.segmentLength;
                const localCenterX = getCanyonCenter(z);
                const localCrossSection = getCrossSectionShape(z);
                const localWidthMult = getCanyonWidthMultiplier(z);
                const localHalfWidth = (CONFIG.canyonWidth / 2) * localWidthMult;

                for (let ix = 0; ix <= segResX; ix++) {
                    const xFrac = ix / segResX;
                    const localX = (xFrac - 0.5) * CONFIG.canyonWidth * localWidthMult;
                    const x = localCenterX + localX;

                    // Floor shape: V has pointed bottom, U has flatter bottom
                    const distFromCenter = Math.abs(localX) / (localHalfWidth);

                    // River channel
                    const riverWidth = 0.15;
                    let height;

                    if (distFromCenter < riverWidth) {
                        // River bed - below raised river level (water area)
                        height = 0 - noise.fbm(z * 0.02, x * 0.1, 3) * 0.5;
                        // Blue reflective water color
                        floorColors.push(0.1, 0.5, 1.0); // RGB for water
                    } else {
                        // Floor rises from center
                        // V-shape: steep rise, U-shape: gradual then steep
                        const uShapeFloor = Math.pow(distFromCenter, 0.5) * 8;
                        const vShapeFloor = distFromCenter * 15;
                        const baseHeight = vShapeFloor * (1 - localCrossSection) + uShapeFloor * localCrossSection;

                        // Add fractal detail - floor is never perfectly flat
                        // Scale with LOD for more detailed terrain at higher settings
                        const lodScale = Math.max(1, CONFIG.lodLevel / 6);
                        const octaves = Math.max(3, Math.min(CONFIG.lodLevel, 8));
                        const detail = noise.fbm(z * 0.01, x * 0.02, octaves, 0.5, 2.0) * (4 * lodScale);
                        height = baseHeight + detail;
                        // Brown rock color
                        floorColors.push(0.4, 0.26, 0.13); // RGB for rock
                    }

                    floorVerts.push(x, height, z);
                }
            }

            // Create indices for walls
            const leftIndices = [];
            const rightIndices = [];
            for (let iz = 0; iz < segResZ; iz++) {
                for (let iy = 0; iy < segResY; iy++) {
                    const a = iz * (segResY + 1) + iy;
                    const b = a + 1;
                    const c = a + (segResY + 1);
                    const d = c + 1;

                    leftIndices.push(a, b, c);
                    leftIndices.push(b, d, c);

                    rightIndices.push(a, c, b);
                    rightIndices.push(b, c, d);
                }
            }

            // Create indices for floor
            const floorIndices = [];
            for (let iz = 0; iz < segResZ; iz++) {
                for (let ix = 0; ix < segResX; ix++) {
                    const a = iz * (segResX + 1) + ix;
                    const b = a + 1;
                    const c = a + (segResX + 1);
                    const d = c + 1;

                    floorIndices.push(a, c, b);
                    floorIndices.push(b, c, d);
                }
            }

            // Set geometry attributes
            leftWallGeo.setAttribute('position', new THREE.Float32BufferAttribute(leftVerts, 3));
            leftWallGeo.setIndex(leftIndices);
            leftWallGeo.computeVertexNormals();

            rightWallGeo.setAttribute('position', new THREE.Float32BufferAttribute(rightVerts, 3));
            rightWallGeo.setIndex(rightIndices);
            rightWallGeo.computeVertexNormals();

            floorGeo.setAttribute('position', new THREE.Float32BufferAttribute(floorVerts, 3));
            floorGeo.setAttribute('color', new THREE.Float32BufferAttribute(floorColors, 3));
            floorGeo.setIndex(floorIndices);
            floorGeo.computeVertexNormals();

            // Materials - smooth shading lets fractal geometry and lighting do the work
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide,
                fog: true
            });

            // Floor material with vertex colors (blue for water, brown for rock)
            const floorMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.3,
                metalness: 0.7,
                vertexColors: true,
                envMapIntensity: 1.5,
                fog: true
            });

            // Create meshes
            const leftWall = new THREE.Mesh(leftWallGeo, wallMaterial);
            leftWall.receiveShadow = true;
            leftWall.castShadow = true;
            segment.add(leftWall);

            const rightWall = new THREE.Mesh(rightWallGeo, wallMaterial);
            rightWall.receiveShadow = true;
            rightWall.castShadow = true;
            segment.add(rightWall);

            const floor = new THREE.Mesh(floorGeo, floorMaterial);
            floor.receiveShadow = true;
            segment.add(floor);

            // Add rings randomly (only if frequency > 0)
            if (CONFIG.ringFrequency > 0 && Math.random() < CONFIG.ringFrequency / 10) {
                createRing(segment, zPosition, canyonCenterX);
            }

            scene.add(segment);
            canyonSegments.push(segment);

            return segment;
        }

        function createRing(parent, zPosition, canyonCenterX) {
            const ringGeo = new THREE.TorusGeometry(12, 0.4, 8, 24);  // Thinner tube: 0.4 instead of 1.0
            const ringMat = new THREE.MeshPhongMaterial({
                color: 0xFFFFFF,  // White
                transparent: true,
                opacity: 0.6,
                emissive: 0xCCCCCC,
                emissiveIntensity: 0.2
            });

            const ring = new THREE.Mesh(ringGeo, ringMat);

            // Random position within canyon bounds, centered on canyon path
            const z = zPosition - Math.random() * CONFIG.segmentLength;
            const localCenterX = getCanyonCenter(z);
            const x = localCenterX + (Math.random() - 0.5) * (CONFIG.canyonWidth - 40);
            const y = 15 + Math.random() * (CONFIG.canyonHeight - 60);

            ring.position.set(x, y, z);

            // Apply rotation based on config setting
            // (by default torus hole points up along Y axis)
            switch (CONFIG.ringRotationAxis) {
                case 'x':
                    ring.rotation.x = Math.PI / 2;
                    break;
                case 'y':
                    ring.rotation.y = Math.PI / 2;
                    break;
                case 'z':
                    ring.rotation.z = Math.PI / 2;
                    break;
                case 'xy':
                    ring.rotation.x = Math.PI / 2;
                    ring.rotation.y = Math.PI / 2;
                    break;
                case 'xz':
                    ring.rotation.x = Math.PI / 2;
                    ring.rotation.z = Math.PI / 2;
                    break;
                case 'yz':
                    ring.rotation.y = Math.PI / 2;
                    ring.rotation.z = Math.PI / 2;
                    break;
            }

            ring.userData.isRing = true;
            ring.userData.collected = false;

            parent.add(ring);
            rings.push(ring);
        }

        function createInitialCanyon() {
            for (let i = 0; i < CONFIG.visibleSegments; i++) {
                const z = -i * CONFIG.segmentLength;
                createCanyonSegment(z);
                lastSegmentZ = z;
            }
        }

        function spawnEnemy() {
            if (!CONFIG.enemiesEnabled) return;

            const enemyGroup = new THREE.Group();

            // Simple enemy plane
            const bodyGeo = new THREE.ConeGeometry(1, 4, 6);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            enemyGroup.add(body);

            const wingGeo = new THREE.BoxGeometry(6, 0.1, 1.2);
            const wingMat = new THREE.MeshPhongMaterial({ color: 0xaa0000 });
            const wings = new THREE.Mesh(wingGeo, wingMat);
            enemyGroup.add(wings);

            // Position enemy ahead of player, following canyon path
            const z = playerZ - 300 - Math.random() * 200;
            const canyonCenterX = getCanyonCenter(z);
            const x = canyonCenterX + (Math.random() - 0.5) * (CONFIG.canyonWidth - 30);
            const y = 15 + Math.random() * 50;

            enemyGroup.position.set(x, y, z);
            enemyGroup.userData.health = 30;
            enemyGroup.userData.lastShot = 0;

            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }

        function createBullet(position, direction, isEnemy = false) {
            const bulletGeo = new THREE.SphereGeometry(0.3, 4, 4);
            const bulletMat = new THREE.MeshBasicMaterial({
                color: isEnemy ? 0xff0000 : 0x00ff00
            });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);

            bullet.position.copy(position);
            bullet.userData.direction = direction.clone();
            bullet.userData.speed = isEnemy ? 300 : 450; // 3x faster
            bullet.userData.velocity = direction.clone().multiplyScalar(bullet.userData.speed);
            bullet.userData.isEnemy = isEnemy;

            scene.add(bullet);

            if (isEnemy) {
                enemyBullets.push(bullet);
            } else {
                bullets.push(bullet);
            }
        }

        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key.toLowerCase() === 'p') {
                    paused = !paused;
                }

                if (e.key === ' ') {
                    e.preventDefault();
                    shootBullet();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Settings controls
            document.getElementById('apply-settings').addEventListener('click', applySettings);
            document.getElementById('restart-btn').addEventListener('click', restartGame);

            // Value display updates
            document.getElementById('canyon-lod').addEventListener('input', (e) => {
                document.getElementById('lod-value').textContent = e.target.value;
            });

            document.getElementById('ring-frequency').addEventListener('input', (e) => {
                document.getElementById('ring-freq-value').textContent = e.target.value;
            });

            document.getElementById('flight-speed').addEventListener('input', (e) => {
                document.getElementById('speed-value').textContent = e.target.value;
            });

            document.getElementById('enemy-difficulty').addEventListener('input', (e) => {
                document.getElementById('enemy-diff-value').textContent = e.target.value;
            });
        }

        function shootBullet() {
            if (gameOver) return;

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(aircraft.quaternion);

            const bulletPos = aircraft.position.clone();
            bulletPos.add(direction.clone().multiplyScalar(3));

            createBullet(bulletPos, direction);
        }

        function applySettings() {
            CONFIG.timeOfDay = document.getElementById('time-of-day').value;
            CONFIG.lodLevel = parseInt(document.getElementById('canyon-lod').value);
            CONFIG.ringFrequency = parseInt(document.getElementById('ring-frequency').value);
            CONFIG.ringRotationAxis = document.getElementById('ring-rotation-axis').value;
            CONFIG.flightSpeed = parseFloat(document.getElementById('flight-speed').value);
            CONFIG.stabilizationEnabled = document.getElementById('stabilization-enabled').checked;
            CONFIG.enemiesEnabled = document.getElementById('enemies-enabled').checked;
            CONFIG.enemyDifficulty = parseInt(document.getElementById('enemy-difficulty').value);

            // Update lighting and skybox
            updateSkybox();
            setupLighting();

            // Regenerate canyon with new LOD and ring settings
            regenerateCanyon();
        }

        function regenerateCanyon() {
            // Clear existing segments
            canyonSegments.forEach(segment => scene.remove(segment));
            canyonSegments = [];
            rings = [];

            // Recreate
            const currentZ = Math.floor(playerZ / CONFIG.segmentLength) * CONFIG.segmentLength;
            for (let i = 0; i < CONFIG.visibleSegments; i++) {
                const z = currentZ - i * CONFIG.segmentLength;
                createCanyonSegment(z);
                lastSegmentZ = z;
            }
        }

        function restartGame() {
            // Reset state
            score = 0;
            ringsCollected = 0;
            health = 100;
            gameOver = false;
            playerZ = 0;
            pitch = 0;
            roll = 0;
            yaw = 0;

            // Reset aircraft
            aircraft.position.set(0, 25, 0);
            aircraft.rotation.set(0, 0, 0);

            // Clear enemies and bullets
            enemies.forEach(e => scene.remove(e));
            bullets.forEach(b => scene.remove(b));
            enemyBullets.forEach(b => scene.remove(b));
            enemies = [];
            bullets = [];
            enemyBullets = [];

            // Regenerate canyon
            regenerateCanyon();

            // Update UI
            updateHUD();
            document.getElementById('game-over').style.display = 'none';
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('rings-collected').textContent = ringsCollected;
            document.getElementById('health').textContent = Math.max(0, health);
        }

        function checkCollisions() {
            const playerPos = aircraft.position;
            const canyonCenterX = getCanyonCenter(playerPos.z);
            const crossSection = getCrossSectionShape(playerPos.z);
            const widthMultiplier = getCanyonWidthMultiplier(playerPos.z);
            const rimHeight = getCanyonRimHeight(playerPos.z);

            // Calculate local position relative to canyon center
            const localX = playerPos.x - canyonCenterX;
            const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;

            // Plane dimensions (F22 model scaled 4x, or fallback delta wing)
            const fuselageRadius = 3;   // Tight around fuselage center
            const wingspan = 24;         // Half-wingspan on each side (48 total)
            const planeLength = 12;      // Front to back

            // Calculate wingtip positions based on roll angle
            // Wings extend along X-axis in local space
            // When rolled, calculate actual wingtip positions in world space
            const rollAngle = roll;  // Current roll angle

            // Left wingtip offset (in world space)
            const leftWingtipX = playerPos.x - Math.cos(rollAngle) * wingspan;
            const leftWingtipY = playerPos.y - Math.sin(rollAngle) * wingspan;

            // Right wingtip offset (in world space)
            const rightWingtipX = playerPos.x + Math.cos(rollAngle) * wingspan;
            const rightWingtipY = playerPos.y + Math.sin(rollAngle) * wingspan;

            // Wall collision - check fuselage and both wingtips
            const yFrac = playerPos.y / rimHeight;
            const baseAngle = 0.15 + crossSection * 0.6;
            const effectiveHalfWidth = halfWidth - (1 - yFrac) * halfWidth * (1 - baseAngle);

            // Check fuselage collision (tight box)
            if (Math.abs(localX) > effectiveHalfWidth - fuselageRadius) {
                triggerDeath();
                return;
            }

            // Check left wingtip collision
            const leftWingtipLocalX = leftWingtipX - canyonCenterX;
            const leftWingtipYFrac = leftWingtipY / rimHeight;
            const leftWingtipEffectiveWidth = halfWidth - (1 - leftWingtipYFrac) * halfWidth * (1 - baseAngle);
            if (Math.abs(leftWingtipLocalX) > leftWingtipEffectiveWidth - 2) {
                triggerDeath();
                return;
            }

            // Check right wingtip collision
            const rightWingtipLocalX = rightWingtipX - canyonCenterX;
            const rightWingtipYFrac = rightWingtipY / rimHeight;
            const rightWingtipEffectiveWidth = halfWidth - (1 - rightWingtipYFrac) * halfWidth * (1 - baseAngle);
            if (Math.abs(rightWingtipLocalX) > rightWingtipEffectiveWidth - 2) {
                triggerDeath();
                return;
            }

            // Floor collision - account for V/U shape and raised river
            // Use tight collision for fuselage bottom
            const distFromCenter = Math.abs(localX) / halfWidth;
            const uShapeFloor = Math.pow(distFromCenter, 0.5) * 8;
            const vShapeFloor = distFromCenter * 15;
            const baseFloorHeight = vShapeFloor * (1 - crossSection) + uShapeFloor * crossSection;
            // River is at level 2, add tighter safety margin
            const floorHeight = Math.max(baseFloorHeight, 2) + 3;  // Tighter: 3 instead of 5

            if (playerPos.y < floorHeight) {
                triggerDeath();
                return;
            }

            // Check if wingtips hit floor (when rolled)
            if (leftWingtipY < 2 || rightWingtipY < 2) {
                triggerDeath();
                return;
            }

            // Ceiling (canyon rim) - cap below the lowest possible rim
            const lowestRim = CONFIG.canyonHeight - 100; // Lowest rim is base - 100
            if (playerPos.y > lowestRim - 10) {
                aircraft.position.y = lowestRim - 10;
            }

            // Ring collection
            rings.forEach((ring, index) => {
                if (!ring.userData.collected) {
                    const worldPos = new THREE.Vector3();
                    ring.getWorldPosition(worldPos);

                    if (playerPos.distanceTo(worldPos) < 14) {  // Increased for larger rings
                        ring.userData.collected = true;
                        ring.visible = false;
                        score += 100;
                        ringsCollected++;
                        updateHUD();
                    }
                }
            });

            // Enemy bullets hitting player
            enemyBullets.forEach((bullet, index) => {
                if (playerPos.distanceTo(bullet.position) < 2) {
                    health -= 10;
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                    updateHUD();

                    if (health <= 0) {
                        triggerDeath();
                    }
                }
            });

            // Player bullets hitting enemies
            bullets.forEach((bullet, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (bullet.position.distanceTo(enemy.position) < 3) {
                        enemy.userData.health -= 20;
                        scene.remove(bullet);
                        bullets.splice(bIndex, 1);

                        if (enemy.userData.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(eIndex, 1);
                            score += 200;
                            updateHUD();
                        }
                    }
                });
            });
        }

        function triggerDeath() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
        }

        function updateAircraft(delta) {
            // Look ahead to follow the optimal path
            const lookAheadDistance = 150;
            const targetZ = aircraft.position.z - lookAheadDistance;

            // Auto-stabilization: follow optimal flight path
            if (CONFIG.stabilizationEnabled) {
                // Get optimal path position at look-ahead point
                const optimalPos = getOptimalFlightPath(targetZ, aircraft.position.x);

                // Get canyon boundaries for wall awareness
                const canyonCenterX = getCanyonCenter(targetZ);
                const widthMultiplier = getCanyonWidthMultiplier(targetZ);
                const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;
                const leftWall = canyonCenterX - halfWidth;
                const rightWall = canyonCenterX + halfWidth;

                // Calculate offsets from optimal path
                const offsetX = aircraft.position.x - optimalPos.x;
                const offsetY = aircraft.position.y - optimalPos.y;

                // Check distance to walls for emergency avoidance
                const distToLeftWall = aircraft.position.x - leftWall;
                const distToRightWall = rightWall - aircraft.position.x;
                const safeDistance = 25; // Trigger avoidance when within 25 units of wall

                // User input modifies roll (2x faster: 4 instead of 2)
                if (keys['a']) roll = Math.max(roll - 4 * delta, -2.1);  // 120 degrees
                else if (keys['d']) roll = Math.min(roll + 4 * delta, 2.1);   // 120 degrees
                else {
                    // Determine desired roll based on situation
                    let targetRoll = 0;

                    // Plane dimensions for wingtip clearance
                    const wingspan = 24;  // Half-wingspan
                    const wingClearance = 8;  // Extra clearance needed

                    // Calculate required clearance for different roll angles
                    // At 0 degrees (level): need full wingspan clearance horizontally
                    // At 90 degrees (knife-edge): need minimal horizontal clearance
                    const levelWingspan = wingspan + wingClearance;

                    // Check if we need to roll to fit through narrow section
                    const availableWidth = Math.min(distToLeftWall, distToRightWall);
                    const needsKnifeEdge = availableWidth < levelWingspan;

                    // Emergency wall avoidance - takes priority
                    if (distToLeftWall < safeDistance) {
                        // Too close to left wall
                        if (needsKnifeEdge) {
                            // Roll to knife-edge to reduce horizontal profile
                            targetRoll = Math.PI / 2;  // 90 degrees (vertical)
                        } else {
                            // Roll right to move away from wall
                            targetRoll = Math.PI / 2;  // 90 degrees right
                        }
                    } else if (distToRightWall < safeDistance) {
                        // Too close to right wall
                        if (needsKnifeEdge) {
                            // Roll to knife-edge to reduce horizontal profile
                            targetRoll = Math.PI / 2;  // 90 degrees (vertical)
                        } else {
                            // Roll left to move away from wall
                            targetRoll = -Math.PI / 2;  // 90 degrees left
                        }
                    } else {
                        // Normal path following
                        // Check if canyon ahead is narrow
                        if (needsKnifeEdge) {
                            // Canyon is narrow - go knife-edge (90 degrees)
                            targetRoll = Math.PI / 2;
                        } else if (Math.abs(offsetX) > 10) {
                            // Large offset - use 90-degree bank for efficient turn
                            targetRoll = offsetX > 0 ? -Math.PI / 2 : Math.PI / 2;
                        } else if (Math.abs(offsetX) > 2) {
                            // Medium offset - use proportional roll
                            targetRoll = THREE.MathUtils.clamp(-offsetX * 0.05, -1.5, 1.5);
                        } else {
                            // Small offset - level out for stability
                            targetRoll = 0;
                        }
                    }

                    roll = THREE.MathUtils.lerp(roll, targetRoll, delta * 5);
                }

                // Pitch control - COMPLETELY SEPARATE from roll
                if (keys['w']) pitch = Math.max(pitch - 2 * delta, -0.8);
                else if (keys['s']) pitch = Math.min(pitch + 2 * delta, 0.8);
                else {
                    // Auto-pitch ONLY for altitude management (no turn coupling)
                    const heightError = optimalPos.y - aircraft.position.y;
                    const desiredPitch = THREE.MathUtils.clamp(heightError * 0.02, -0.3, 0.3);
                    pitch = THREE.MathUtils.lerp(pitch, desiredPitch, delta * 3);
                }
            } else {
                // Manual control without stabilization
                if (keys['w']) pitch = Math.max(pitch - 2 * delta, -0.8);
                else if (keys['s']) pitch = Math.min(pitch + 2 * delta, 0.8);
                else pitch *= 0.95;  // Decay pitch when not actively controlling

                // 2x faster roll: 4 instead of 2, 120-degree limit: 2.1 instead of 1.0
                if (keys['a']) roll = Math.max(roll - 4 * delta, -2.1);
                else if (keys['d']) roll = Math.min(roll + 4 * delta, 2.1);
                else roll *= 0.95;  // Decay roll when not actively controlling

                // Don't accumulate yaw - it causes spinning
                yaw *= 0.98;  // Slowly decay yaw
            }

            // Apply rotations using quaternions for proper local-axis rotation
            // Order: Roll first, then pitch around the rolled axis
            const qRoll = new THREE.Quaternion();
            qRoll.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -roll);

            const qPitch = new THREE.Quaternion();
            qPitch.setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitch);

            const qYaw = new THREE.Quaternion();
            qYaw.setFromAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

            // Combine rotations: Yaw * Roll * Pitch
            aircraft.quaternion.copy(qYaw);
            aircraft.quaternion.multiply(qRoll);
            aircraft.quaternion.multiply(qPitch);

            // Calculate direction the nose is pointing
            const noseDirection = new THREE.Vector3(0, 0, -1);
            noseDirection.applyQuaternion(aircraft.quaternion);

            // Move ONLY in the direction the nose is pointing
            const speed = 50 * CONFIG.flightSpeed * delta;
            const movement = noseDirection.multiplyScalar(speed);
            aircraft.position.add(movement);

            // Update debug arrows with actual travel direction
            updateDebugArrows(movement);

            // Clamp vertical position only
            const lowestRim = CONFIG.canyonHeight - 100;
            aircraft.position.y = Math.max(8, Math.min(lowestRim - 10, aircraft.position.y));

            playerZ = aircraft.position.z;

            // Update camera to follow aircraft (not canyon)
            camera.position.x = aircraft.position.x;
            camera.position.y = aircraft.position.y + 5;
            camera.position.z = aircraft.position.z + 25;

            // Look ahead in the direction the plane is facing
            const cameraLookAhead = 50;
            const lookTarget = aircraft.position.clone();
            lookTarget.z -= cameraLookAhead;

            camera.lookAt(lookTarget);
        }

        function updateCanyon() {
            // Remove old segments and add new ones
            const playerSegment = Math.floor(-playerZ / CONFIG.segmentLength);

            // Create new segments ahead
            while (-lastSegmentZ < -playerZ + CONFIG.visibleSegments * CONFIG.segmentLength) {
                lastSegmentZ -= CONFIG.segmentLength;
                createCanyonSegment(lastSegmentZ);
            }

            // Remove segments behind
            canyonSegments = canyonSegments.filter(segment => {
                if (segment.userData.zPosition > playerZ + CONFIG.segmentLength * 2) {
                    scene.remove(segment);
                    return false;
                }
                return true;
            });

            // Clean up old rings
            rings = rings.filter(ring => {
                const worldPos = new THREE.Vector3();
                ring.getWorldPosition(worldPos);
                return worldPos.z < playerZ + 100;
            });
        }

        function updateEnemies(delta) {
            if (!CONFIG.enemiesEnabled) return;

            // Spawn new enemies
            if (Math.random() < 0.005 * CONFIG.enemyDifficulty && enemies.length < 5) {
                spawnEnemy();
            }

            const now = Date.now();

            enemies.forEach((enemy, index) => {
                // Move enemy towards player
                const toPlayer = aircraft.position.clone().sub(enemy.position);
                toPlayer.normalize();

                // Enemy movement
                enemy.position.add(toPlayer.multiplyScalar(20 * delta));
                enemy.lookAt(aircraft.position);

                // Enemy shooting
                const shootInterval = 2000 - CONFIG.enemyDifficulty * 150;
                if (now - enemy.userData.lastShot > shootInterval) {
                    const direction = aircraft.position.clone().sub(enemy.position).normalize();
                    createBullet(enemy.position.clone(), direction, true);
                    enemy.userData.lastShot = now;
                }

                // Remove if too far behind
                if (enemy.position.z > playerZ + 100) {
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                }
            });
        }

        function updateBullets(delta) {
            const gravity = 30; // Bullet drop

            // Player bullets
            bullets.forEach((bullet, index) => {
                // Apply velocity
                bullet.position.add(
                    bullet.userData.velocity.clone().multiplyScalar(delta)
                );

                // Apply gravity (bullet drop)
                bullet.userData.velocity.y -= gravity * delta;

                // Remove if too far
                if (bullet.position.distanceTo(aircraft.position) > 500) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            // Enemy bullets
            enemyBullets.forEach((bullet, index) => {
                // Apply velocity
                bullet.position.add(
                    bullet.userData.velocity.clone().multiplyScalar(delta)
                );

                // Apply gravity (bullet drop)
                bullet.userData.velocity.y -= gravity * delta;

                // Remove if too far
                if (bullet.position.distanceTo(aircraft.position) > 300) {
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                }
            });
        }

        // Animation loop
        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (!gameOver && !paused) {
                updateAircraft(delta);
                updateCanyon();
                updateEnemies(delta);
                updateBullets(delta);
                updateLightingPosition();
                updateDebugLines();
                updateDebugCircles();
                checkCollisions();
            }

            // Update skybox position to follow player
            const skybox = scene.getObjectByName('skybox');
            if (skybox && aircraft) {
                skybox.position.copy(aircraft.position);
            }

            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
