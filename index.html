<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canyon Flight</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
        }

        #hud div {
            margin-bottom: 8px;
        }

        #controls-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 14px;
            max-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #controls-panel h3 {
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 8px;
        }

        #controls-panel label {
            display: block;
            margin: 8px 0 4px;
        }

        #controls-panel input[type="range"] {
            width: 100%;
        }

        #controls-panel select, #controls-panel button {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            border-radius: 4px;
            border: none;
        }

        #controls-panel button {
            background: #4CAF50;
            color: white;
            cursor: pointer;
            margin-top: 10px;
        }

        #controls-panel button:hover {
            background: #45a049;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .checkbox-container input {
            margin-right: 8px;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.85);
            padding: 40px;
            border-radius: 12px;
            color: white;
            text-align: center;
            display: none;
        }

        #game-over h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff4444;
        }

        #game-over p {
            font-size: 20px;
            margin-bottom: 20px;
        }

        #game-over button {
            padding: 12px 30px;
            font-size: 18px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
        }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            text-align: center;
        }

        .value-display {
            color: #88ff88;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div>Score: <span id="score">0</span></div>
            <div>Rings: <span id="rings-collected">0</span></div>
            <div>Health: <span id="health">100</span></div>
        </div>

        <div id="controls-panel">
            <h3>Settings</h3>

            <label>Time of Day:</label>
            <select id="time-of-day">
                <option value="morning" selected>Morning (Fog)</option>
                <option value="noon">Noon</option>
                <option value="sunset">Sunset</option>
            </select>

            <label>Canyon Detail (LOD): <span id="lod-value" class="value-display">12</span></label>
            <input type="range" id="canyon-lod" min="2" max="20" value="12">

            <label>Ring Frequency: <span id="ring-freq-value" class="value-display">3</span></label>
            <input type="range" id="ring-frequency" min="0" max="10" value="3">

            <label>Flight Speed: <span id="speed-value" class="value-display">1.5</span>x</label>
            <input type="range" id="flight-speed" min="0.5" max="3" step="0.1" value="1.5">

            <div class="checkbox-container">
                <input type="checkbox" id="stabilization-enabled" checked>
                <label for="stabilization-enabled">Auto-stabilization</label>
            </div>

            <div class="checkbox-container">
                <input type="checkbox" id="enemies-enabled">
                <label for="enemies-enabled">Enable Enemy Planes</label>
            </div>

            <label>Enemy Difficulty: <span id="enemy-diff-value" class="value-display">5</span></label>
            <input type="range" id="enemy-difficulty" min="1" max="10" value="5">

            <button id="apply-settings">Apply Settings</button>
        </div>

        <div id="game-over">
            <h2>CRASHED!</h2>
            <p>Final Score: <span id="final-score">0</span></p>
            <button id="restart-btn">Restart</button>
        </div>

        <div id="instructions">
            <strong>Controls:</strong> W/S - Pitch | A/D - Roll | Space - Shoot | P - Pause
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Game Configuration
        const CONFIG = {
            canyonWidth: 120,
            canyonHeight: 200,
            canyonDepth: 2000,
            segmentLength: 100,
            visibleSegments: 25,
            lodLevel: 12,
            ringFrequency: 3,
            flightSpeed: 1.5,
            enemiesEnabled: false,
            enemyDifficulty: 5,
            timeOfDay: 'morning',
            stabilizationEnabled: true
        };

        // Game State
        let score = 0;
        let ringsCollected = 0;
        let health = 100;
        let gameOver = false;
        let paused = false;

        // Three.js components
        // This work is based on "F22 (Remaster)" (https://sketchfab.com/3d-models/f22-remaster-bf6df655e73e4d4b9deac6cfee85564c) by CreaDX (https://sketchfab.com/CreaDX) licensed under CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
        let scene, camera, renderer;
        let aircraft, aircraftGroup;
        let canyonSegments = [];
        let rings = [];
        let enemies = [];
        let bullets = [];
        let enemyBullets = [];
        let debugCenterline = null;

        // Controls
        const keys = {};
        let pitch = 0;
        let roll = 0;
        let yaw = 0;

        // Position tracking
        let playerZ = 0;
        let lastSegmentZ = 0;

        // Canyon path - stores the center X position at each Z
        const canyonPath = new Map();

        // Noise function for fractal terrain
        class SimplexNoise {
            constructor(seed = Math.random()) {
                this.p = new Uint8Array(256);
                for (let i = 0; i < 256; i++) this.p[i] = i;

                // Shuffle
                let n, q;
                for (let i = 255; i > 0; i--) {
                    n = Math.floor((seed = (seed * 16807) % 2147483647) / 2147483647 * (i + 1));
                    q = this.p[i];
                    this.p[i] = this.p[n];
                    this.p[n] = q;
                }

                this.perm = new Uint8Array(512);
                for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
            }

            noise2D(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                x -= Math.floor(x);
                y -= Math.floor(y);
                const u = this.fade(x);
                const v = this.fade(y);
                const A = this.perm[X] + Y;
                const B = this.perm[X + 1] + Y;
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[A], x, y), this.grad(this.perm[B], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[A + 1], x, y - 1), this.grad(this.perm[B + 1], x - 1, y - 1))
                );
            }

            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
            }

            // Fractal Brownian Motion for more detailed terrain
            fbm(x, y, octaves = 6, persistence = 0.5, lacunarity = 2.0) {
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    value += amplitude * this.noise2D(x * frequency, y * frequency);
                    maxValue += amplitude;
                    amplitude *= persistence;
                    frequency *= lacunarity;
                }

                return value / maxValue;
            }
        }

        const noise = new SimplexNoise(12345);
        const pathNoise = new SimplexNoise(67890);

        // Get canyon center position at a given Z
        function getCanyonCenter(z) {
            // Create pronounced S-curves with varying radius and angle
            // Primary large S-curves
            const curve1 = pathNoise.noise2D(z * 0.0015, 0) * 80;
            // Secondary curves for variation in turn radius
            const curve2 = pathNoise.noise2D(z * 0.004, 100) * 40;
            // Tertiary detail curves
            const curve3 = pathNoise.noise2D(z * 0.01, 200) * 15;
            // Extra variation in turn sharpness
            const curve4 = Math.sin(z * 0.002 + pathNoise.noise2D(z * 0.001, 300) * 2) * 50;

            return curve1 + curve2 + curve3 + curve4;
        }

        // Get cross-section shape factor (0 = V-shape, 1 = U-shape)
        function getCrossSectionShape(z) {
            return (pathNoise.noise2D(z * 0.005, 500) + 1) / 2;
        }

        // Get canyon width multiplier (varies between 1x and 2x)
        function getCanyonWidthMultiplier(z) {
            return 1.0 + (pathNoise.noise2D(z * 0.003, 700) + 1) / 2;
        }

        // Get canyon rim height variation (dramatic variation)
        function getCanyonRimHeight(z) {
            // Base height + dramatic variation
            const base = CONFIG.canyonHeight;
            const variation = pathNoise.noise2D(z * 0.004, 900) * 200; // +/- 200 units (2x max height)
            return base + variation;
        }

        // Initialize the game
        function init() {
            // Scene setup
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 10, 30);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Create game elements
            createSkybox();
            setupLighting();
            createAircraft();
            createInitialCanyon();

            // Event listeners
            setupEventListeners();

            // Start game loop
            animate();
        }

        function createSkybox() {
            updateSkybox();
        }

        function updateSkybox(centerOnPlayer = false) {
            // Remove old skybox
            const oldSkybox = scene.getObjectByName('skybox');
            if (oldSkybox) scene.remove(oldSkybox);

            let skyColors;
            switch (CONFIG.timeOfDay) {
                case 'morning':
                    skyColors = {
                        top: new THREE.Color(0x87CEEB),
                        bottom: new THREE.Color(0xFFE4B5)
                    };
                    break;
                case 'noon':
                    skyColors = {
                        top: new THREE.Color(0x0077FF),
                        bottom: new THREE.Color(0x87CEEB)
                    };
                    break;
                case 'sunset':
                    skyColors = {
                        top: new THREE.Color(0x1a0533),
                        bottom: new THREE.Color(0xFF6B35)
                    };
                    break;
            }

            // Set up fog for morning
            if (CONFIG.timeOfDay === 'morning') {
                // Exponential fog that follows camera automatically
                scene.fog = new THREE.FogExp2(0xE8E8E8, 0.006);
            } else {
                scene.fog = null;
            }

            // Gradient sky sphere
            const skyGeo = new THREE.SphereGeometry(2000, 32, 32);
            const skyMat = new THREE.ShaderMaterial({
                uniforms: {
                    topColor: { value: skyColors.top },
                    bottomColor: { value: skyColors.bottom },
                    offset: { value: 400 },
                    exponent: { value: 0.6 }
                },
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 topColor;
                    uniform vec3 bottomColor;
                    uniform float offset;
                    uniform float exponent;
                    varying vec3 vWorldPosition;
                    void main() {
                        float h = normalize(vWorldPosition + offset).y;
                        gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                    }
                `,
                side: THREE.BackSide
            });

            const sky = new THREE.Mesh(skyGeo, skyMat);
            sky.name = 'skybox';

            // Center on player if requested
            if (centerOnPlayer && aircraft) {
                sky.position.copy(aircraft.position);
            }

            scene.add(sky);
        }


        let sunLight, sunVisual;

        function setupLighting() {
            // Remove old lights and sun visual
            scene.children = scene.children.filter(child =>
                !(child instanceof THREE.Light) && child.name !== 'sunVisual'
            );
            sunLight = null;
            sunVisual = null;

            // Ambient light
            let ambientIntensity, ambientColor;
            let sunPosition, sunColor, sunIntensity;

            switch (CONFIG.timeOfDay) {
                case 'morning':
                    ambientIntensity = 0.4;
                    ambientColor = 0xB0C4DE;
                    sunPosition = new THREE.Vector3(100, 30, -100);
                    sunColor = 0xFFE4C4;
                    sunIntensity = 1.0;
                    break;
                case 'noon':
                    // Harsh directional light for noon
                    ambientIntensity = 0.2;
                    ambientColor = 0xFFFFFF;
                    sunPosition = new THREE.Vector3(0, 200, -50);
                    sunColor = 0xFFFFFF;
                    sunIntensity = 2.5;
                    break;
                case 'sunset':
                    ambientIntensity = 0.3;
                    ambientColor = 0xFF8C69;
                    sunPosition = new THREE.Vector3(-200, 20, -100);
                    sunColor = 0xFF4500;
                    sunIntensity = 1.2;
                    break;
            }

            const ambient = new THREE.AmbientLight(ambientColor, ambientIntensity);
            scene.add(ambient);

            // Directional light (sun)
            sunLight = new THREE.DirectionalLight(sunColor, sunIntensity);
            sunLight.position.copy(sunPosition);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -150;
            sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150;
            sunLight.shadow.camera.bottom = -150;
            sunLight.userData.initialPosition = sunPosition.clone();
            scene.add(sunLight);

            // Add sun visual for sunset
            if (CONFIG.timeOfDay === 'sunset') {
                const sunGeo = new THREE.SphereGeometry(30, 32, 32);
                const sunMat = new THREE.MeshBasicMaterial({
                    color: 0xFF6600,
                    transparent: true,
                    opacity: 0.9
                });
                sunVisual = new THREE.Mesh(sunGeo, sunMat);
                sunVisual.position.copy(sunPosition).multiplyScalar(5);
                sunVisual.name = 'sunVisual';
                sunVisual.userData.initialPosition = sunVisual.position.clone();
                scene.add(sunVisual);
            }
        }

        function updateLightingPosition() {
            if (sunLight && aircraft) {
                const offset = sunLight.userData.initialPosition;
                sunLight.position.copy(aircraft.position).add(offset);
                sunLight.target.position.copy(aircraft.position);
                sunLight.target.updateMatrixWorld();
            }
            if (sunVisual && aircraft) {
                const offset = sunVisual.userData.initialPosition;
                sunVisual.position.copy(aircraft.position).add(offset);
            }
        }

        function updateDebugCenterline() {
            // Remove old centerline
            if (debugCenterline) {
                scene.remove(debugCenterline);
            }

            // Create points along canyon center
            const points = [];
            const startZ = playerZ + 100;  // Start behind player
            const endZ = playerZ - 800;    // Extend far ahead
            const step = 10;               // Point spacing
            const waterlineHeight = 3;     // Just above the water

            for (let z = startZ; z >= endZ; z -= step) {
                const centerX = getCanyonCenter(z);
                points.push(new THREE.Vector3(centerX, waterlineHeight, z));
            }

            // Create fat dotted line
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineDashedMaterial({
                color: 0xFF00FF,      // Bright magenta for visibility
                linewidth: 5,         // Fat line (note: may not work on all platforms)
                scale: 1,
                dashSize: 5,
                gapSize: 3
            });

            debugCenterline = new THREE.Line(geometry, material);
            debugCenterline.computeLineDistances();  // Required for dashed lines
            scene.add(debugCenterline);
        }

        function createAircraft() {
            aircraftGroup = new THREE.Group();

            // F22-style materials
            const bodyMat = new THREE.MeshPhongMaterial({
                color: 0x6B7280,  // Gray military color
                flatShading: true
            });
            const darkMat = new THREE.MeshPhongMaterial({
                color: 0x4B5563,  // Darker gray
                flatShading: true
            });

            // Main fuselage (flat angular body like F22)
            const fuselageGeo = new THREE.BoxGeometry(1.2, 0.8, 5);
            const fuselage = new THREE.Mesh(fuselageGeo, bodyMat);
            fuselage.position.z = 0.5;
            fuselage.castShadow = true;
            aircraftGroup.add(fuselage);

            // Nose cone (pointed front)
            const noseGeo = new THREE.ConeGeometry(0.6, 1.5, 4);
            const nose = new THREE.Mesh(noseGeo, darkMat);
            nose.rotation.x = -Math.PI / 2;
            nose.position.z = -2.5;
            nose.position.y = 0;
            nose.castShadow = true;
            aircraftGroup.add(nose);

            // Delta wings (swept back triangular - F22 style)
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0);
            wingShape.lineTo(5, 0);
            wingShape.lineTo(1, 2.5);
            wingShape.lineTo(0, 2.5);
            const wingGeo = new THREE.ExtrudeGeometry(wingShape, {
                depth: 0.15,
                bevelEnabled: false
            });

            // Left wing
            const leftWing = new THREE.Mesh(wingGeo, bodyMat);
            leftWing.rotation.x = Math.PI / 2;
            leftWing.rotation.z = Math.PI;
            leftWing.position.set(-0.6, 0, 1);
            leftWing.castShadow = true;
            aircraftGroup.add(leftWing);

            // Right wing
            const rightWing = new THREE.Mesh(wingGeo, bodyMat);
            rightWing.rotation.x = -Math.PI / 2;
            rightWing.position.set(0.6, 0, 1);
            rightWing.castShadow = true;
            aircraftGroup.add(rightWing);

            // Twin tail fins (F22 has twin vertical stabilizers)
            const tailFinGeo = new THREE.BufferGeometry();
            const tailVerts = new Float32Array([
                0, 0, 0,
                0.8, 0, 0,
                0.5, 1.8, 0,
                0, 0, 0.2,
                0.8, 0, 0.2,
                0.5, 1.8, 0.2
            ]);
            const tailIndices = [
                0, 2, 1,  0, 1, 3,  1, 4, 3,
                3, 4, 5,  2, 5, 4,  0, 3, 5,  0, 5, 2
            ];
            tailFinGeo.setAttribute('position', new THREE.BufferAttribute(tailVerts, 3));
            tailFinGeo.setIndex(tailIndices);
            tailFinGeo.computeVertexNormals();

            // Left tail fin
            const leftTail = new THREE.Mesh(tailFinGeo, darkMat);
            leftTail.position.set(-0.8, 0, 2.2);
            leftTail.rotation.y = Math.PI / 12;  // Slight outward angle
            leftTail.castShadow = true;
            aircraftGroup.add(leftTail);

            // Right tail fin
            const rightTail = new THREE.Mesh(tailFinGeo, darkMat);
            rightTail.position.set(0, 0, 2.2);
            rightTail.rotation.y = -Math.PI / 12;  // Slight outward angle
            rightTail.castShadow = true;
            aircraftGroup.add(rightTail);

            // Horizontal stabilizers (small)
            const hStabGeo = new THREE.BoxGeometry(2, 0.1, 0.8);
            const hStab = new THREE.Mesh(hStabGeo, bodyMat);
            hStab.position.z = 2.8;
            hStab.position.y = 0.3;
            hStab.castShadow = true;
            aircraftGroup.add(hStab);

            // Canopy (F22 style bubble canopy)
            const canopyGeo = new THREE.SphereGeometry(0.5, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const canopyMat = new THREE.MeshPhongMaterial({
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.6,
                flatShading: true
            });
            const canopy = new THREE.Mesh(canopyGeo, canopyMat);
            canopy.position.z = -0.5;
            canopy.position.y = 0.6;
            canopy.scale.z = 1.3;
            aircraftGroup.add(canopy);

            // Engine intakes (F22 has distinctive intakes)
            const intakeGeo = new THREE.BoxGeometry(0.4, 0.4, 1.5);
            const intakeMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });

            const leftIntake = new THREE.Mesh(intakeGeo, intakeMat);
            leftIntake.position.set(-0.5, -0.3, 1.5);
            aircraftGroup.add(leftIntake);

            const rightIntake = new THREE.Mesh(intakeGeo, intakeMat);
            rightIntake.position.set(0.5, -0.3, 1.5);
            aircraftGroup.add(rightIntake);

            aircraftGroup.position.set(0, 25, 0);
            aircraftGroup.scale.set(1.2, 1.2, 1.2);  // Scale up slightly
            aircraft = aircraftGroup;
            scene.add(aircraftGroup);
        }

        function createCanyonSegment(zPosition) {
            const segment = new THREE.Group();
            segment.userData.zPosition = zPosition;

            const resolution = CONFIG.lodLevel;

            // Get canyon center for this segment
            const segmentCenterZ = zPosition - CONFIG.segmentLength / 2;
            const canyonCenterX = getCanyonCenter(segmentCenterZ);
            const crossSection = getCrossSectionShape(segmentCenterZ);
            const widthMultiplier = getCanyonWidthMultiplier(segmentCenterZ);
            const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;

            // Create canyon geometry with varying cross-section
            const leftWallGeo = new THREE.BufferGeometry();
            const rightWallGeo = new THREE.BufferGeometry();
            const floorGeo = new THREE.BufferGeometry();

            const segResZ = resolution;
            const segResY = Math.floor(resolution / 2);
            const segResX = resolution;

            // Generate wall vertices
            const leftVerts = [];
            const rightVerts = [];
            const floorVerts = [];
            const floorColors = [];
            const leftNormals = [];
            const rightNormals = [];
            const floorNormals = [];

            // Create walls with varying angle based on cross-section
            for (let iz = 0; iz <= segResZ; iz++) {
                const zFrac = iz / segResZ;
                const z = zPosition - zFrac * CONFIG.segmentLength;
                const localCenterX = getCanyonCenter(z);
                const localCrossSection = getCrossSectionShape(z);
                const localWidthMult = getCanyonWidthMultiplier(z);
                const localHalfWidth = (CONFIG.canyonWidth / 2) * localWidthMult;
                const localRimHeight = getCanyonRimHeight(z);

                for (let iy = 0; iy <= segResY; iy++) {
                    const yFrac = iy / segResY;
                    const y = yFrac * localRimHeight;

                    // Wall angle: V-shape has angled walls, U-shape has more vertical walls
                    // But never perfectly vertical
                    const baseAngle = 0.15 + localCrossSection * 0.6; // 0.15 to 0.75
                    const wallAngle = baseAngle + noise.fbm(z * 0.01, y * 0.02, 3) * 0.1;

                    // At the top, walls extend outward/back so player can't see the edge
                    let topExtension = 0;
                    if (yFrac > 0.7) {
                        // Smoothly extend walls outward near the top
                        const extendFrac = (yFrac - 0.7) / 0.3;
                        topExtension = extendFrac * extendFrac * 60; // Quadratic curve outward
                    }

                    // Left wall X position (wall leans inward at bottom for V, straighter for U)
                    const leftBaseX = localCenterX - localHalfWidth + (1 - yFrac) * localHalfWidth * (1 - wallAngle) - topExtension;
                    const leftDisplacement = noise.fbm(z * 0.01, y * 0.05, CONFIG.lodLevel) * 15;  // Increased from 8 to 15
                    const leftX = leftBaseX - leftDisplacement;

                    // Right wall X position
                    const rightBaseX = localCenterX + localHalfWidth - (1 - yFrac) * localHalfWidth * (1 - wallAngle) + topExtension;
                    const rightDisplacement = noise.fbm(z * 0.01 + 100, y * 0.05, CONFIG.lodLevel) * 15;  // Increased from 8 to 15
                    const rightX = rightBaseX + rightDisplacement;

                    leftVerts.push(leftX, y, z);
                    rightVerts.push(rightX, y, z);
                }
            }

            // Create floor with varying shape
            for (let iz = 0; iz <= segResZ; iz++) {
                const zFrac = iz / segResZ;
                const z = zPosition - zFrac * CONFIG.segmentLength;
                const localCenterX = getCanyonCenter(z);
                const localCrossSection = getCrossSectionShape(z);
                const localWidthMult = getCanyonWidthMultiplier(z);
                const localHalfWidth = (CONFIG.canyonWidth / 2) * localWidthMult;

                for (let ix = 0; ix <= segResX; ix++) {
                    const xFrac = ix / segResX;
                    const localX = (xFrac - 0.5) * CONFIG.canyonWidth * localWidthMult;
                    const x = localCenterX + localX;

                    // Floor shape: V has pointed bottom, U has flatter bottom
                    const distFromCenter = Math.abs(localX) / (localHalfWidth);

                    // River channel
                    const riverWidth = 0.15;
                    let height;

                    if (distFromCenter < riverWidth) {
                        // River bed - below raised river level (water area)
                        height = 0 - noise.fbm(z * 0.02, x * 0.1, 3) * 0.5;
                        // Blue reflective water color
                        floorColors.push(0.1, 0.5, 1.0); // RGB for water
                    } else {
                        // Floor rises from center
                        // V-shape: steep rise, U-shape: gradual then steep
                        const uShapeFloor = Math.pow(distFromCenter, 0.5) * 8;
                        const vShapeFloor = distFromCenter * 15;
                        const baseHeight = vShapeFloor * (1 - localCrossSection) + uShapeFloor * localCrossSection;

                        // Add fractal detail - floor is never perfectly flat
                        const detail = noise.fbm(z * 0.01, x * 0.02, CONFIG.lodLevel) * 6;  // Increased from 3 to 6
                        height = baseHeight + detail;
                        // Brown rock color
                        floorColors.push(0.4, 0.26, 0.13); // RGB for rock
                    }

                    floorVerts.push(x, height, z);
                }
            }

            // Create indices for walls
            const leftIndices = [];
            const rightIndices = [];
            for (let iz = 0; iz < segResZ; iz++) {
                for (let iy = 0; iy < segResY; iy++) {
                    const a = iz * (segResY + 1) + iy;
                    const b = a + 1;
                    const c = a + (segResY + 1);
                    const d = c + 1;

                    leftIndices.push(a, b, c);
                    leftIndices.push(b, d, c);

                    rightIndices.push(a, c, b);
                    rightIndices.push(b, c, d);
                }
            }

            // Create indices for floor
            const floorIndices = [];
            for (let iz = 0; iz < segResZ; iz++) {
                for (let ix = 0; ix < segResX; ix++) {
                    const a = iz * (segResX + 1) + ix;
                    const b = a + 1;
                    const c = a + (segResX + 1);
                    const d = c + 1;

                    floorIndices.push(a, c, b);
                    floorIndices.push(b, c, d);
                }
            }

            // Set geometry attributes
            leftWallGeo.setAttribute('position', new THREE.Float32BufferAttribute(leftVerts, 3));
            leftWallGeo.setIndex(leftIndices);
            leftWallGeo.computeVertexNormals();

            rightWallGeo.setAttribute('position', new THREE.Float32BufferAttribute(rightVerts, 3));
            rightWallGeo.setIndex(rightIndices);
            rightWallGeo.computeVertexNormals();

            floorGeo.setAttribute('position', new THREE.Float32BufferAttribute(floorVerts, 3));
            floorGeo.setAttribute('color', new THREE.Float32BufferAttribute(floorColors, 3));
            floorGeo.setIndex(floorIndices);
            floorGeo.computeVertexNormals();

            // Materials - smooth shading lets fractal geometry and lighting do the work
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x8B4513,
                roughness: 0.9,
                metalness: 0.1,
                side: THREE.DoubleSide
            });

            // Floor material with vertex colors (blue for water, brown for rock)
            const floorMaterial = new THREE.MeshStandardMaterial({
                roughness: 0.3,
                metalness: 0.7,
                vertexColors: true,
                envMapIntensity: 1.5
            });

            // Create meshes
            const leftWall = new THREE.Mesh(leftWallGeo, wallMaterial);
            leftWall.receiveShadow = true;
            leftWall.castShadow = true;
            segment.add(leftWall);

            const rightWall = new THREE.Mesh(rightWallGeo, wallMaterial);
            rightWall.receiveShadow = true;
            rightWall.castShadow = true;
            segment.add(rightWall);

            const floor = new THREE.Mesh(floorGeo, floorMaterial);
            floor.receiveShadow = true;
            segment.add(floor);

            // Add rings randomly (only if frequency > 0)
            if (CONFIG.ringFrequency > 0 && Math.random() < CONFIG.ringFrequency / 10) {
                createRing(segment, zPosition, canyonCenterX);
            }

            scene.add(segment);
            canyonSegments.push(segment);

            return segment;
        }

        function createRing(parent, zPosition, canyonCenterX) {
            const ringGeo = new THREE.TorusGeometry(12, 1.0, 8, 24);  // Larger ring: radius 12, tube 1.0
            const ringMat = new THREE.MeshPhongMaterial({
                color: 0xFFD700,
                emissive: 0x886600,
                emissiveIntensity: 0.3
            });

            const ring = new THREE.Mesh(ringGeo, ringMat);

            // Random position within canyon bounds, centered on canyon path
            const z = zPosition - Math.random() * CONFIG.segmentLength;
            const localCenterX = getCanyonCenter(z);
            const x = localCenterX + (Math.random() - 0.5) * (CONFIG.canyonWidth - 40);
            const y = 15 + Math.random() * (CONFIG.canyonHeight - 60);

            ring.position.set(x, y, z);
            // Rotate 90 degrees so axis lines up with canyon (points along Z axis)
            ring.rotation.x = Math.PI / 2;
            ring.userData.isRing = true;
            ring.userData.collected = false;

            parent.add(ring);
            rings.push(ring);
        }

        function createInitialCanyon() {
            for (let i = 0; i < CONFIG.visibleSegments; i++) {
                const z = -i * CONFIG.segmentLength;
                createCanyonSegment(z);
                lastSegmentZ = z;
            }
        }

        function spawnEnemy() {
            if (!CONFIG.enemiesEnabled) return;

            const enemyGroup = new THREE.Group();

            // Simple enemy plane
            const bodyGeo = new THREE.ConeGeometry(1, 4, 6);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.rotation.x = Math.PI / 2;
            enemyGroup.add(body);

            const wingGeo = new THREE.BoxGeometry(6, 0.1, 1.2);
            const wingMat = new THREE.MeshPhongMaterial({ color: 0xaa0000 });
            const wings = new THREE.Mesh(wingGeo, wingMat);
            enemyGroup.add(wings);

            // Position enemy ahead of player, following canyon path
            const z = playerZ - 300 - Math.random() * 200;
            const canyonCenterX = getCanyonCenter(z);
            const x = canyonCenterX + (Math.random() - 0.5) * (CONFIG.canyonWidth - 30);
            const y = 15 + Math.random() * 50;

            enemyGroup.position.set(x, y, z);
            enemyGroup.userData.health = 30;
            enemyGroup.userData.lastShot = 0;

            scene.add(enemyGroup);
            enemies.push(enemyGroup);
        }

        function createBullet(position, direction, isEnemy = false) {
            const bulletGeo = new THREE.SphereGeometry(0.3, 4, 4);
            const bulletMat = new THREE.MeshBasicMaterial({
                color: isEnemy ? 0xff0000 : 0x00ff00
            });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);

            bullet.position.copy(position);
            bullet.userData.direction = direction.clone();
            bullet.userData.speed = isEnemy ? 300 : 450; // 3x faster
            bullet.userData.velocity = direction.clone().multiplyScalar(bullet.userData.speed);
            bullet.userData.isEnemy = isEnemy;

            scene.add(bullet);

            if (isEnemy) {
                enemyBullets.push(bullet);
            } else {
                bullets.push(bullet);
            }
        }

        function setupEventListeners() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;

                if (e.key.toLowerCase() === 'p') {
                    paused = !paused;
                }

                if (e.key === ' ') {
                    e.preventDefault();
                    shootBullet();
                }
            });

            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Settings controls
            document.getElementById('apply-settings').addEventListener('click', applySettings);
            document.getElementById('restart-btn').addEventListener('click', restartGame);

            // Value display updates
            document.getElementById('canyon-lod').addEventListener('input', (e) => {
                document.getElementById('lod-value').textContent = e.target.value;
            });

            document.getElementById('ring-frequency').addEventListener('input', (e) => {
                document.getElementById('ring-freq-value').textContent = e.target.value;
            });

            document.getElementById('flight-speed').addEventListener('input', (e) => {
                document.getElementById('speed-value').textContent = e.target.value;
            });

            document.getElementById('enemy-difficulty').addEventListener('input', (e) => {
                document.getElementById('enemy-diff-value').textContent = e.target.value;
            });
        }

        function shootBullet() {
            if (gameOver) return;

            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(aircraft.quaternion);

            const bulletPos = aircraft.position.clone();
            bulletPos.add(direction.clone().multiplyScalar(3));

            createBullet(bulletPos, direction);
        }

        function applySettings() {
            CONFIG.timeOfDay = document.getElementById('time-of-day').value;
            CONFIG.lodLevel = parseInt(document.getElementById('canyon-lod').value);
            CONFIG.ringFrequency = parseInt(document.getElementById('ring-frequency').value);
            CONFIG.flightSpeed = parseFloat(document.getElementById('flight-speed').value);
            CONFIG.stabilizationEnabled = document.getElementById('stabilization-enabled').checked;
            CONFIG.enemiesEnabled = document.getElementById('enemies-enabled').checked;
            CONFIG.enemyDifficulty = parseInt(document.getElementById('enemy-difficulty').value);

            // Update lighting and skybox
            updateSkybox();
            setupLighting();

            // Regenerate canyon with new LOD
            regenerateCanyon();
        }

        function regenerateCanyon() {
            // Clear existing segments
            canyonSegments.forEach(segment => scene.remove(segment));
            canyonSegments = [];
            rings = [];

            // Recreate
            const currentZ = Math.floor(playerZ / CONFIG.segmentLength) * CONFIG.segmentLength;
            for (let i = 0; i < CONFIG.visibleSegments; i++) {
                const z = currentZ - i * CONFIG.segmentLength;
                createCanyonSegment(z);
                lastSegmentZ = z;
            }
        }

        function restartGame() {
            // Reset state
            score = 0;
            ringsCollected = 0;
            health = 100;
            gameOver = false;
            playerZ = 0;
            pitch = 0;
            roll = 0;
            yaw = 0;

            // Reset aircraft
            aircraft.position.set(0, 25, 0);
            aircraft.rotation.set(0, 0, 0);

            // Clear enemies and bullets
            enemies.forEach(e => scene.remove(e));
            bullets.forEach(b => scene.remove(b));
            enemyBullets.forEach(b => scene.remove(b));
            enemies = [];
            bullets = [];
            enemyBullets = [];

            // Regenerate canyon
            regenerateCanyon();

            // Update UI
            updateHUD();
            document.getElementById('game-over').style.display = 'none';
        }

        function updateHUD() {
            document.getElementById('score').textContent = score;
            document.getElementById('rings-collected').textContent = ringsCollected;
            document.getElementById('health').textContent = Math.max(0, health);
        }

        function checkCollisions() {
            const playerPos = aircraft.position;
            const canyonCenterX = getCanyonCenter(playerPos.z);
            const crossSection = getCrossSectionShape(playerPos.z);
            const widthMultiplier = getCanyonWidthMultiplier(playerPos.z);
            const rimHeight = getCanyonRimHeight(playerPos.z);

            // Calculate local position relative to canyon center
            const localX = playerPos.x - canyonCenterX;
            const halfWidth = (CONFIG.canyonWidth / 2) * widthMultiplier;

            // Wall collision - account for sloped walls
            const yFrac = playerPos.y / rimHeight;
            const baseAngle = 0.15 + crossSection * 0.6;
            const effectiveHalfWidth = halfWidth - (1 - yFrac) * halfWidth * (1 - baseAngle) - 8;

            if (Math.abs(localX) > effectiveHalfWidth) {
                triggerDeath();
                return;
            }

            // Floor collision - account for V/U shape and raised river
            const distFromCenter = Math.abs(localX) / halfWidth;
            const uShapeFloor = Math.pow(distFromCenter, 0.5) * 8;
            const vShapeFloor = distFromCenter * 15;
            const baseFloorHeight = vShapeFloor * (1 - crossSection) + uShapeFloor * crossSection;
            // River is at level 2, add safety margin
            const floorHeight = Math.max(baseFloorHeight, 2) + 5;

            if (playerPos.y < floorHeight) {
                triggerDeath();
                return;
            }

            // Ceiling (canyon rim) - cap below the lowest possible rim
            const lowestRim = CONFIG.canyonHeight - 100; // Lowest rim is base - 100
            if (playerPos.y > lowestRim - 10) {
                aircraft.position.y = lowestRim - 10;
            }

            // Ring collection
            rings.forEach((ring, index) => {
                if (!ring.userData.collected) {
                    const worldPos = new THREE.Vector3();
                    ring.getWorldPosition(worldPos);

                    if (playerPos.distanceTo(worldPos) < 14) {  // Increased for larger rings
                        ring.userData.collected = true;
                        ring.visible = false;
                        score += 100;
                        ringsCollected++;
                        updateHUD();
                    }
                }
            });

            // Enemy bullets hitting player
            enemyBullets.forEach((bullet, index) => {
                if (playerPos.distanceTo(bullet.position) < 2) {
                    health -= 10;
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                    updateHUD();

                    if (health <= 0) {
                        triggerDeath();
                    }
                }
            });

            // Player bullets hitting enemies
            bullets.forEach((bullet, bIndex) => {
                enemies.forEach((enemy, eIndex) => {
                    if (bullet.position.distanceTo(enemy.position) < 3) {
                        enemy.userData.health -= 20;
                        scene.remove(bullet);
                        bullets.splice(bIndex, 1);

                        if (enemy.userData.health <= 0) {
                            scene.remove(enemy);
                            enemies.splice(eIndex, 1);
                            score += 200;
                            updateHUD();
                        }
                    }
                });
            });
        }

        function triggerDeath() {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over').style.display = 'block';
        }

        function updateAircraft(delta) {
            const canyonCenterX = getCanyonCenter(aircraft.position.z);

            // Auto-stabilization: follow canyon center
            if (CONFIG.stabilizationEnabled) {
                // Calculate desired roll to follow canyon
                const localX = aircraft.position.x - canyonCenterX;
                const desiredRoll = -localX * 0.01; // Proportional control

                // User input modifies roll
                if (keys['a']) roll = Math.max(roll - 2 * delta, -1.0);
                else if (keys['d']) roll = Math.min(roll + 2 * delta, 1.0);
                else {
                    // Auto-roll towards desired position
                    const rollDiff = desiredRoll - roll;
                    roll += rollDiff * 2 * delta; // Smooth interpolation
                }

                // Pitch control
                if (keys['w']) pitch = Math.max(pitch - 2 * delta, -0.8);
                else if (keys['s']) pitch = Math.min(pitch + 2 * delta, 0.8);
                else pitch *= 0.95;
            } else {
                // Manual control without stabilization
                if (keys['w']) pitch = Math.max(pitch - 2 * delta, -0.8);
                else if (keys['s']) pitch = Math.min(pitch + 2 * delta, 0.8);

                if (keys['a']) roll = Math.max(roll - 2 * delta, -1.0);
                else if (keys['d']) roll = Math.min(roll + 2 * delta, 1.0);

                // Yaw based on roll (banking turns)
                yaw += roll * delta * 0.5;
                aircraft.rotation.y = yaw;
            }

            // Apply rotation
            aircraft.rotation.x = pitch;
            aircraft.rotation.z = -roll;

            // Calculate movement directions in plane's local coordinate system
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(aircraft.quaternion);

            const localUp = new THREE.Vector3(0, 1, 0);
            localUp.applyQuaternion(aircraft.quaternion);

            // Move aircraft forward
            const speed = 50 * CONFIG.flightSpeed * delta;
            aircraft.position.add(forward.multiplyScalar(speed));

            // Pitch movement is now relative to plane's roll (along local up direction)
            // When rolled 90Â° left, pitching "up" moves left, creating a turn
            const pitchSpeed = -pitch * 30 * delta;
            aircraft.position.add(localUp.multiplyScalar(pitchSpeed));

            // Clamp vertical position only
            const lowestRim = CONFIG.canyonHeight - 100;
            aircraft.position.y = Math.max(8, Math.min(lowestRim - 10, aircraft.position.y));

            playerZ = aircraft.position.z;

            // Update camera to follow aircraft
            const lookAheadZ = aircraft.position.z - 50;
            const lookAheadCenterX = getCanyonCenter(lookAheadZ);

            camera.position.x = aircraft.position.x * 0.7 + canyonCenterX * 0.3;
            camera.position.y = aircraft.position.y + 5;
            camera.position.z = aircraft.position.z + 25;
            camera.lookAt(
                aircraft.position.x * 0.5 + lookAheadCenterX * 0.5,
                aircraft.position.y,
                lookAheadZ
            );
        }

        function updateCanyon() {
            // Remove old segments and add new ones
            const playerSegment = Math.floor(-playerZ / CONFIG.segmentLength);

            // Create new segments ahead
            while (-lastSegmentZ < -playerZ + CONFIG.visibleSegments * CONFIG.segmentLength) {
                lastSegmentZ -= CONFIG.segmentLength;
                createCanyonSegment(lastSegmentZ);
            }

            // Remove segments behind
            canyonSegments = canyonSegments.filter(segment => {
                if (segment.userData.zPosition > playerZ + CONFIG.segmentLength * 2) {
                    scene.remove(segment);
                    return false;
                }
                return true;
            });

            // Clean up old rings
            rings = rings.filter(ring => {
                const worldPos = new THREE.Vector3();
                ring.getWorldPosition(worldPos);
                return worldPos.z < playerZ + 100;
            });
        }

        function updateEnemies(delta) {
            if (!CONFIG.enemiesEnabled) return;

            // Spawn new enemies
            if (Math.random() < 0.005 * CONFIG.enemyDifficulty && enemies.length < 5) {
                spawnEnemy();
            }

            const now = Date.now();

            enemies.forEach((enemy, index) => {
                // Move enemy towards player
                const toPlayer = aircraft.position.clone().sub(enemy.position);
                toPlayer.normalize();

                // Enemy movement
                enemy.position.add(toPlayer.multiplyScalar(20 * delta));
                enemy.lookAt(aircraft.position);

                // Enemy shooting
                const shootInterval = 2000 - CONFIG.enemyDifficulty * 150;
                if (now - enemy.userData.lastShot > shootInterval) {
                    const direction = aircraft.position.clone().sub(enemy.position).normalize();
                    createBullet(enemy.position.clone(), direction, true);
                    enemy.userData.lastShot = now;
                }

                // Remove if too far behind
                if (enemy.position.z > playerZ + 100) {
                    scene.remove(enemy);
                    enemies.splice(index, 1);
                }
            });
        }

        function updateBullets(delta) {
            const gravity = 30; // Bullet drop

            // Player bullets
            bullets.forEach((bullet, index) => {
                // Apply velocity
                bullet.position.add(
                    bullet.userData.velocity.clone().multiplyScalar(delta)
                );

                // Apply gravity (bullet drop)
                bullet.userData.velocity.y -= gravity * delta;

                // Remove if too far
                if (bullet.position.distanceTo(aircraft.position) > 500) {
                    scene.remove(bullet);
                    bullets.splice(index, 1);
                }
            });

            // Enemy bullets
            enemyBullets.forEach((bullet, index) => {
                // Apply velocity
                bullet.position.add(
                    bullet.userData.velocity.clone().multiplyScalar(delta)
                );

                // Apply gravity (bullet drop)
                bullet.userData.velocity.y -= gravity * delta;

                // Remove if too far
                if (bullet.position.distanceTo(aircraft.position) > 300) {
                    scene.remove(bullet);
                    enemyBullets.splice(index, 1);
                }
            });
        }

        // Animation loop
        let lastTime = 0;
        function animate(currentTime = 0) {
            requestAnimationFrame(animate);

            const delta = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            if (!gameOver && !paused) {
                updateAircraft(delta);
                updateCanyon();
                updateEnemies(delta);
                updateBullets(delta);
                updateLightingPosition();
                updateDebugCenterline();
                checkCollisions();
            }

            // Update skybox position to follow player
            const skybox = scene.getObjectByName('skybox');
            if (skybox && aircraft) {
                skybox.position.copy(aircraft.position);
            }

            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>
